///////////////////////////////////////////////////////////////////////////////
//
// File CoupledLinearNS_trafoP.cpp
//
// For more information, please see: http://www.nektar.info
//
// The MIT License
//
// Copyright (c) 2006 Division of Applied Mathematics, Brown University (USA),
// Department of Aeronautics, Imperial College London (UK), and Scientific
// Computing and Imaging Institute, University of Utah (USA).
//
// License for the specific language governing rights and limitations under
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the "Software"),
// to deal in the Software without restriction, including without limitation
// the rights to use, copy, modify, merge, publish, distribute, sublicense,
// and/or sell copies of the Software, and to permit persons to whom the
// Software is furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
// THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
// FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.
//
// Description: Coupled  Solver for the Linearised Incompressible
// Navier Stokes equations
///////////////////////////////////////////////////////////////////////////////

#include <boost/algorithm/string.hpp>

#include <LibUtilities/TimeIntegration/TimeIntegrationWrapper.h>
#include "CoupledLinearNS_trafoP.h"
#include <LibUtilities/BasicUtils/Timer.h>
#include <LocalRegions/MatrixKey.h>
#include <MultiRegions/GlobalLinSysDirectStaticCond.h>

#include <vector>


using namespace std;

namespace Nektar
{

    string CoupledLinearNS_trafoP::className = SolverUtils::GetEquationSystemFactory().RegisterCreatorFunction("CoupledLinearisedNS_trafoP", CoupledLinearNS_trafoP::create);


    /**
     *  @class CoupledLinearNS_trafoP 
     *
     * Set up expansion field for velocity and pressure, the local to
     * global mapping arrays and the basic memory definitions for
     * coupled matrix system
     */ 
    CoupledLinearNS_trafoP::CoupledLinearNS_trafoP(const LibUtilities::SessionReaderSharedPtr &pSession):
        UnsteadySystem(pSession),
        CoupledLinearNS(pSession),
        m_zeroMode(false)
    {
    }

    void CoupledLinearNS_trafoP::v_InitObject()
    {
    	second_param = 1;
        IncNavierStokes::v_InitObject();

        int  i;
        int  expdim = m_graph->GetMeshDimension();

        // Get Expansion list for orthogonal expansion at p-2
        const SpatialDomains::ExpansionMap &pressure_exp = GenPressureExp(m_graph->GetExpansions("u"));

        m_nConvectiveFields = m_fields.num_elements();
        if(boost::iequals(m_boundaryConditions->GetVariable(m_nConvectiveFields-1), "p"))
        {
            ASSERTL0(false,"Last field is defined as pressure but this is not suitable for this solver, please remove this field as it is implicitly defined");
        }
        // Decide how to declare explist for pressure. 
        if(expdim == 2)
        {
            int nz; 

            if(m_HomogeneousType == eHomogeneous1D)
            {
                ASSERTL0(m_fields.num_elements() > 2,"Expect to have three at least three components of velocity variables");
                LibUtilities::BasisKey Homo1DKey = m_fields[0]->GetHomogeneousBasis()->GetBasisKey();

                m_pressure = MemoryManager<MultiRegions::ExpList3DHomogeneous1D>::AllocateSharedPtr(m_session, Homo1DKey, m_LhomZ, m_useFFT,m_homogen_dealiasing, pressure_exp);

                ASSERTL1(m_npointsZ%2==0,"Non binary number of planes have been specified");
                nz = m_npointsZ/2;                

            }
            else
            {
                //m_pressure2 = MemoryManager<MultiRegions::ContField2D>::AllocateSharedPtr(m_session, pressure_exp);
                m_pressure = MemoryManager<MultiRegions::ExpList2D>::AllocateSharedPtr(m_session, pressure_exp);
                nz = 1;
            }

            Array<OneD, MultiRegions::ExpListSharedPtr> velocity(m_velocity.num_elements());
            for(i =0 ; i < m_velocity.num_elements(); ++i)
            {
                velocity[i] = m_fields[m_velocity[i]];
            }

            // Set up Array of mappings
            m_locToGloMap = Array<OneD, CoupledLocalToGlobalC0ContMapSharedPtr> (nz);

            if(m_singleMode)
            {

                ASSERTL0(nz <=2 ,"For single mode calculation can only have  nz <= 2");
                if(m_session->DefinesSolverInfo("BetaZero"))
                {
                    m_zeroMode = true;
                }
                int nz_loc = 2;
                m_locToGloMap[0] = MemoryManager<CoupledLocalToGlobalC0ContMap>::AllocateSharedPtr(m_session,m_graph,m_boundaryConditions,velocity,m_pressure,nz_loc,m_zeroMode);
            }
            else 
            {
                // base mode
                int nz_loc = 1;
                m_locToGloMap[0] = MemoryManager<CoupledLocalToGlobalC0ContMap>::AllocateSharedPtr(m_session,m_graph,m_boundaryConditions,velocity,m_pressure,nz_loc);

                if(nz > 1)
                {
                    nz_loc = 2;
                    // Assume all higher modes have the same boundary conditions and re-use mapping
                    m_locToGloMap[1] = MemoryManager<CoupledLocalToGlobalC0ContMap>::AllocateSharedPtr(m_session,m_graph,m_boundaryConditions,velocity,m_pressure->GetPlane(2),nz_loc,false);
                    // Note high order modes cannot be singular
                    for(i = 2; i < nz; ++i)
                    {
                        m_locToGloMap[i] = m_locToGloMap[1];
                    }
                }
            }
        }
        else if (expdim == 3)
        {
            //m_pressure = MemoryManager<MultiRegions::ExpList3D>::AllocateSharedPtr(pressure_exp);
            ASSERTL0(false,"Setup mapping aray");
        }
        else
        {
            ASSERTL0(false,"Exp dimension not recognised");
        }

        // creation of the extrapolation object
        if(m_equationType == eUnsteadyNavierStokes)
        {
            std::string vExtrapolation = "Standard";

            if (m_session->DefinesSolverInfo("Extrapolation"))
            {
                vExtrapolation = m_session->GetSolverInfo("Extrapolation");
            }

            m_extrapolation = GetExtrapolateFactory().CreateInstance(
                vExtrapolation,
                m_session,
                m_fields,
                m_pressure,
                m_velocity,
                m_advObject);
        }

    }
    
    /**
     * Set up a coupled linearised Naviers-Stokes solve. Primarily a
     * wrapper fuction around the full mode by mode version of
     * SetUpCoupledMatrix.
     * 
     */
    void CoupledLinearNS_trafoP::SetUpCoupledMatrix(const NekDouble lambda,  const Array< OneD, Array< OneD, NekDouble > > &Advfield, bool IsLinearNSEquation)
    {
        
        int nz;
        if(m_singleMode)
        {
            NekDouble lambda_imag; 
            
            // load imaginary component of any potential shift
            // Probably should be called from DriverArpack but not yet
            // clear how to do this
            m_session->LoadParameter("imagShift",lambda_imag,NekConstants::kNekUnsetDouble);
            nz = 1;
            m_mat  = Array<OneD, CoupledSolverMatrices> (nz);
            
            ASSERTL1(m_npointsZ <=2,"Only expected a maxmimum of two planes in single mode linear NS solver");
            
            if(m_zeroMode)
            {
                SetUpCoupledMatrix(lambda,Advfield,IsLinearNSEquation,0,m_mat[0],m_locToGloMap[0],lambda_imag);
            }
            else
            {
                NekDouble beta =  2*M_PI/m_LhomZ; 
                NekDouble lam = lambda + m_kinvis*beta*beta;
                
                SetUpCoupledMatrix(lam,Advfield,IsLinearNSEquation,1,m_mat[0],m_locToGloMap[0],lambda_imag);
            }
        }
        else 
        {
            int n;
            if(m_npointsZ > 1)
            { 
                nz = m_npointsZ/2;
            }
            else
            {
                nz =  1;
            }
            
            m_mat  = Array<OneD, CoupledSolverMatrices> (nz);
            
            // mean mode or 2D mode.
            SetUpCoupledMatrix(lambda,Advfield,IsLinearNSEquation,0,m_mat[0],m_locToGloMap[0]);
            
            for(n = 1; n < nz; ++n)
            {
                NekDouble beta = 2*M_PI*n/m_LhomZ;
                
                NekDouble lam = lambda + m_kinvis*beta*beta;
                
                SetUpCoupledMatrix(lam,Advfield,IsLinearNSEquation,n,m_mat[n],m_locToGloMap[n]);
            }
        }
        
    }
    
    
    /**
     * Set up a coupled linearised Naviers-Stokes solve in the
     * following manner: 
     * 
     * Consider the linearised Navier-Stokes element matrix denoted as
     * 
     * \f[ \left [ \begin{array}{ccc} A
     * & -D_{bnd}^T & B\\ -D_{bnd}& 0 & -D_{int}\\ \tilde{B}^T &
     * -D_{int}^T & C \end{array} \right ] \left [ \begin{array}{c} {\bf
     * v}_{bnd} \\ p\\ {\bf v}_{int} \end{array} \right ] = \left [
     * \begin{array}{c} {\bf f}_{bnd} \\ 0\\ {\bf f}_{int} \end{array}
     * \right ] \f] 
     * 
     * where \f${\bf v}_{bnd}, {\bf f}_{bnd}\f$ denote the degrees of
     * freedom of the elemental velocities on the boundary of the
     * element, \f${\bf v}_{int}, {\bf f}_{int}\f$ denote the degrees
     * of freedom of the elemental velocities on the interior of the
     * element and \f$p\f$ is the piecewise continuous pressure.  The
     * matrices have the interpretation
     * 
     * \f[  A[n,m]  = (\nabla \phi^b_n, \nu \nabla
     * \phi^b_m) + (\phi^b_n,{\bf U \cdot \nabla} \phi^b_m) +
     * (\phi^b_n \nabla^T {\bf U} \phi^b_m), \f] 
     * 
     * \f[ B[n,m] = (\nabla \phi^b_n, \nu \nabla \phi^i_m) +
     * (\phi^b_n,{\bf U \cdot \nabla} \phi^i_m) + (\phi^b_n \nabla^T
     * {\bf U} \phi^i_m),\f]
     * 
     * \f[\tilde{B}^T[n,m] = (\nabla \phi^i_n, \nu \nabla \phi^b_m) +
     * (\phi^i_n,{\bf U \cdot \nabla} \phi^b_m) + (\phi^i_n \nabla^T
     * {\bf U} \phi^b_m) \f]
     * 
     * \f[ C[n,m] = (\nabla \phi^i_n, \nu \nabla
     * \phi^i_m) + (\phi^i_n,{\bf U \cdot \nabla} \phi^i_m) +
     * (\phi^i_n \nabla^T {\bf U} \phi^i_m),\f]
     * 
     * \f[ D_{bnd}[n,m] = (\psi_m,\nabla \phi^b),\f]
     * 
     * \f[ D_{int}[n,m] = (\psi_m,\nabla \phi^i) \f]
     * 
     * where \f$\psi\f$ is the space of pressures typically at order
     * \f$P-2\f$ and \f$\phi\f$ is the velocity vector space of
     * polynomial order \f$P\f$. (Note the above definitions for the
     * transpose terms shoudl be interpreted with care since we have
     * used a tensor differential for the \f$\nabla^T \f$ terms)
     * 
     * Note \f$B = \tilde{B}^T\f$ if just considering the stokes
     * operator and then \f$C\f$ is also symmetric. Also note that
     * \f$A,B\f$ and \f$C\f$ are block diagonal in the Oseen equation
     * when \f$\nabla^T {\bf U}\f$ are zero.
     * 
     * Since \f$C\f$ is invertible we can premultiply the governing
     * elemental equation by the following matrix: 
     * 
     * \f[  \left [ \begin{array}{ccc} I & 0 &
     * -BC^{-1}\\ 0& I & D_{int}C^{-1}\\ 0 & 0 & I \end{array}
     * \right ] \left \{ \left [ \begin{array}{ccc} A & -D_{bnd}^T &
     * B\\ -D_{bnd}& 0 & -D_{int}\\ \tilde{B}^T & -D_{int}^T & C
     * \end{array} \right ] \left [ \begin{array}{c} {\bf v}_{bnd} \\
     * p\\ {\bf v_{int}} \end{array} \right ] = \left [
     * \begin{array}{c} {\bf f}_{bnd} \\ 0\\ {\bf f_{int}} \end{array}
     * \right ] \right \} \f]
     * 
     *  which if we multiply out the matrix equation we obtain
     * 
     * \f[ \left [ \begin{array}{ccc} A - B
     * C^{-1}\tilde{B}^T & -D_{bnd}^T +B C^{-1} D_{int}^T& 0\\
     * -D_{bnd}+D_{int} C^{-1} \tilde{B}^T & -D_{int} C^{-1}
     * D_{int}^T & 0\\ \tilde{B}^T & -D_{int}^T & C \end{array} \right ]
     * \left [ \begin{array}{c} {\bf v}_{bnd} \\ p\\ {\bf v_{int}}
     * \end{array} \right ] = \left [ \begin{array}{c} {\bf f}_{bnd}
     * -B C^{-1} {\bf f}_{int}\\ f_p = D_{int} C^{-1} {\bf
     * f}_{int}\\ {\bf f_{int}} \end{array} \right ] \f]
     *
     * In the above equation the \f${\bf v}_{int}\f$ degrees of freedom
     * are decoupled and so we need to solve for the \f${\bf v}_{bnd},
     * p\f$ degrees of freedom.  The final step is to perform a second
     * level of static condensation but where we will lump the mean
     * pressure mode (or a pressure degree of freedom containing a
     * mean component) with the velocity boundary degrees of
     * freedom. To do we define \f${\bf b} = [{\bf v}_{bnd}, p_0]\f$ where
     * \f$p_0\f$ is the mean pressure mode and \f$\hat{p}\f$ to be the
     * remainder of the pressure space.  We now repartition the top \f$2
     * \times 2\f$ block of matrices of previous matrix equation  as
     * 
     * \f[ \left [ \begin{array}{cc} \hat{A} & \hat{B}\\ \hat{C} &
     * \hat{D} \end{array} \right ] \left [ \begin{array}{c} {\bf b}
     * \\ \hat{p} \end{array} \right ] = \left [ \begin{array}{c}
     * \hat{\bf f}_{bnd} \\ \hat{f}_p \end{array} \right ]
     * \label{eqn.linNS_fac2} \f]
     * 
     * where 
     * 
     * \f[ \hat{A}_{ij} = \left [ \begin{array}{cc} A - B
     * C^{-1}\tilde{B}^T & [-D_{bnd}^T +B C^{-1} D_{int}^T]_{i0}\\
     * {[}-D_{bnd}+D_{int} C^{-1} \tilde{B}^T]_{0j} & -[D_{int}
     * C^{-1} D_{int}^T ]_{00} \end{array} \right ] \f] 
     * 
     * \f[ \hat{B}_{ij} = \left [ \begin{array}{c} [-D_{bnd}^T +B
     * C^{-1} D_{int}^T]_{i,j+1} \\ {[} -D_{int} C^{-1} D^T_{int}
     * ]_{0j}\end{array} \right ] \f]
     * 
     * \f[ \hat{C}_{ij}  =  \left [\begin{array}{cc} -D_{bnd} + 
     * D_{int} C^{-1} \tilde{B}^T, & {[} -D_{int} C^{-1} D^T_{int}
     * ]_{i+1,0}\end{array} \right ] \f]
     * 
     * \f[ \hat{D}_{ij}  =  \left [\begin{array}{c} {[} -D_{int}
     * C^{-1} D^T_{int} ]_{i+1,j+1}\end{array} \right ] \f]
     *
     * and 
     *
     * \f[ fh\_{bnd} = \left [ \begin{array}{c} {\bf
     * f}_{bnd} -B C^{-1} {\bf f}_{int}\\ {[}D_{int} C^{-1} {\bf
     * f}_{int}]_0 \end{array}\right ] \hspace{1cm} [fh\_p_{i} =
     * \left [ \begin{array}{c} {[}D_{int} C^{-1} {\bf f}_{iint}]_{i+1}
     * \end{array}\right ] \f]
     * 
     * Since the \f$\hat{D}\f$ is decoupled and invertible we can now
     * statically condense the previous matrix equationto decouple
     * \f${\bf b}\f$ from \f$\hat{p}\f$ by solving the following system
     * 
     * \f[ \left [ \begin{array}{cc} \hat{A} - \hat{B} \hat{D}^{-1}
     * \hat{C} & 0 \\ \hat{C} & \hat{D} \end{array} \right ] \left
     * [ \begin{array}{c} {\bf b} \\ \hat{p} \end{array} \right ] =
     * \left [ \begin{array}{c} \hat{\bf f}_{bnd} - \hat{B}
     * \hat{D}^{-1} \hat{f}_p\\ \hat{f}_p \end{array} \right ] \f] 
     * 
     * The matrix \f$\hat{A} - \hat{B} \hat{D}^{-1} \hat{C}\f$ has
     * to be globally assembled and solved iteratively or
     * directly. One we obtain the solution to \f${\bf b}\f$ we can use
     * the second row of equation fourth matrix equation to solve for
     * \f$\hat{p}\f$ and finally the last row of equation second
     * matrix equation to solve for \f${\bf v}_{int}\f$.
     *
     */
    
    void CoupledLinearNS_trafoP::SetUpCoupledMatrix(const NekDouble lambda,  const Array< OneD, Array< OneD, NekDouble > > &Advfield, bool IsLinearNSEquation,const int HomogeneousMode, CoupledSolverMatrices &mat, CoupledLocalToGlobalC0ContMapSharedPtr &locToGloMap, const NekDouble lambda_imag)
    {
		if(use_Newton)        
		{
			IsLinearNSEquation = true;
		}

        int  n,i,j,k,eid;
        int  nel  = m_fields[m_velocity[0]]->GetNumElmts();
        int  nvel   = m_velocity.num_elements();
        
        // if Advfield is defined can assume it is an Oseen or LinearNS equation
        bool AddAdvectionTerms = (Advfield ==  NullNekDoubleArrayofArray)? false: true; 
        //bool AddAdvectionTerms = true; // Temporary debugging trip
        
        // call velocity space Static condensation and fill block
        // matrices.  Need to set this up differently for Oseen and
        // Lin NS.  Ideally should make block diagonal for Stokes and
        // Oseen problems.
        DNekScalMatSharedPtr loc_mat;
        StdRegions::StdExpansionSharedPtr locExp;
        NekDouble one = 1.0;
        int nint,nbndry;
        int rows, cols;
        NekDouble zero = 0.0;
        Array<OneD, unsigned int> bmap,imap; 
        
        Array<OneD,unsigned int> nsize_bndry   (nel);
        Array<OneD,unsigned int> nsize_bndry_p1(nel);
        Array<OneD,unsigned int> nsize_int     (nel);
        Array<OneD,unsigned int> nsize_p       (nel);
        Array<OneD,unsigned int> nsize_p_m1    (nel);
        
        int nz_loc;
        
        if(HomogeneousMode) // Homogeneous mode flag
        {
            nz_loc = 2;
        }
        else
        {
            if(m_singleMode)
            {
                nz_loc = 2;
            }
            else
            {
                nz_loc = 1;
            }
        }
        
        // Set up block matrix sizes - 
        for(n = 0; n < nel; ++n)
        {
            eid = n;
            nsize_bndry[n] = nvel*m_fields[m_velocity[0]]->GetExp(eid)->NumBndryCoeffs()*nz_loc;
            nsize_bndry_p1[n] = nsize_bndry[n]+nz_loc;
            nsize_int  [n] = (nvel*m_fields[m_velocity[0]]->GetExp(eid)->GetNcoeffs()*nz_loc - nsize_bndry[n]);
            nsize_p[n] = m_pressure->GetExp(eid)->GetNcoeffs()*nz_loc;
            nsize_p_m1[n] = nsize_p[n]-nz_loc;
        }
        
        MatrixStorage blkmatStorage = eDIAGONAL;
        DNekScalBlkMatSharedPtr pAh = MemoryManager<DNekScalBlkMat>
        ::AllocateSharedPtr(nsize_bndry_p1,nsize_bndry_p1,blkmatStorage);
        mat.m_BCinv = MemoryManager<DNekScalBlkMat>
        ::AllocateSharedPtr(nsize_bndry,nsize_int,blkmatStorage);
        mat.m_Btilde = MemoryManager<DNekScalBlkMat>
        ::AllocateSharedPtr(nsize_bndry,nsize_int,blkmatStorage);
        mat.m_Cinv = MemoryManager<DNekScalBlkMat>
        ::AllocateSharedPtr(nsize_int,nsize_int,blkmatStorage);
        
        mat.m_D_bnd = MemoryManager<DNekScalBlkMat>
        ::AllocateSharedPtr(nsize_p,nsize_bndry,blkmatStorage);
        
        mat.m_D_int = MemoryManager<DNekScalBlkMat>
        ::AllocateSharedPtr(nsize_p,nsize_int,blkmatStorage);
        
        // Final level static condensation matrices. 
        DNekScalBlkMatSharedPtr pBh = MemoryManager<DNekScalBlkMat>
        ::AllocateSharedPtr(nsize_bndry_p1,nsize_p_m1,blkmatStorage);
        DNekScalBlkMatSharedPtr pCh = MemoryManager<DNekScalBlkMat>
        ::AllocateSharedPtr(nsize_p_m1,nsize_bndry_p1,blkmatStorage);
        DNekScalBlkMatSharedPtr pDh = MemoryManager<DNekScalBlkMat>
        ::AllocateSharedPtr(nsize_p_m1,nsize_p_m1,blkmatStorage);
        
        
        Timer timer;
        timer.Start();
        for(n = 0; n < nel; ++n)
        {
            eid = n;
            nbndry = nsize_bndry[n];
            nint   = nsize_int[n];
            k = nsize_bndry_p1[n];
            DNekMatSharedPtr Ah = MemoryManager<DNekMat>::AllocateSharedPtr(k,k,zero);
            Array<OneD, NekDouble> Ah_data = Ah->GetPtr();
            int AhRows = k;
            DNekMatSharedPtr B  = MemoryManager<DNekMat>::AllocateSharedPtr(nbndry,nint,zero);
            Array<OneD, NekDouble> B_data = B->GetPtr();
            DNekMatSharedPtr C  = MemoryManager<DNekMat>::AllocateSharedPtr(nbndry,nint,zero);
            Array<OneD, NekDouble> C_data = C->GetPtr();
            DNekMatSharedPtr D  = MemoryManager<DNekMat>::AllocateSharedPtr(nint, nint,zero);
            Array<OneD, NekDouble> D_data = D->GetPtr();
            
            DNekMatSharedPtr Dbnd = MemoryManager<DNekMat>::AllocateSharedPtr(nsize_p[n],nsize_bndry[n],zero);
            DNekMatSharedPtr Dint = MemoryManager<DNekMat>::AllocateSharedPtr(nsize_p[n],nsize_int[n],zero);
            
            locExp = m_fields[m_velocity[0]]->GetExp(eid);
            locExp->GetBoundaryMap(bmap);
            locExp->GetInteriorMap(imap);
            StdRegions::ConstFactorMap factors;
            factors[StdRegions::eFactorLambda] = lambda/m_kinvis;
            LocalRegions::MatrixKey helmkey(StdRegions::eHelmholtz,
                                            locExp->DetShapeType(),
                                            *locExp,
                                            factors);
            
            
            int ncoeffs = m_fields[m_velocity[0]]->GetExp(eid)->GetNcoeffs();
            int nphys   = m_fields[m_velocity[0]]->GetExp(eid)->GetTotPoints();
            int nbmap = bmap.num_elements();
            int nimap = imap.num_elements(); 
            
            Array<OneD, NekDouble> coeffs(ncoeffs);
            Array<OneD, NekDouble> phys  (nphys);
            int psize   = m_pressure->GetExp(eid)->GetNcoeffs();
            int pqsize  = m_pressure->GetExp(eid)->GetTotPoints();
            
            Array<OneD, NekDouble> deriv  (pqsize);
            Array<OneD, NekDouble> pcoeffs(psize);
            
            if(AddAdvectionTerms == false) // use static condensed managed matrices
            {
                // construct velocity matrices using statically
                // condensed elemental matrices and then construct
                // pressure matrix systems
                DNekScalBlkMatSharedPtr CondMat; 
                CondMat = locExp->GetLocStaticCondMatrix(helmkey);
                
                for(k = 0; k < nvel*nz_loc; ++k)
                {
                    DNekScalMat &SubBlock = *CondMat->GetBlock(0,0);
                    rows = SubBlock.GetRows();
                    cols = SubBlock.GetColumns(); 
                    for(i = 0; i < rows; ++i)
                    {
                        for(j = 0; j < cols; ++j)
                        {
                            (*Ah)(i+k*rows,j+k*cols) = m_kinvis*SubBlock(i,j);
                        }                        
                    }
                }
                
                for(k = 0; k < nvel*nz_loc; ++k)
                {
                    DNekScalMat &SubBlock  = *CondMat->GetBlock(0,1);
                    DNekScalMat &SubBlock1 = *CondMat->GetBlock(1,0);
                    rows = SubBlock.GetRows();
                    cols = SubBlock.GetColumns(); 
                    for(i = 0; i < rows; ++i)
                    {
                        for(j = 0; j < cols; ++j)
                        {
                            (*B)(i+k*rows,j+k*cols) = SubBlock(i,j);
                            (*C)(i+k*rows,j+k*cols) = m_kinvis*SubBlock1(j,i);
                        }
                    }
                }
                
                for(k = 0; k < nvel*nz_loc; ++k)
                {
                    DNekScalMat &SubBlock = *CondMat->GetBlock(1,1);
                    NekDouble inv_kinvis = 1.0/m_kinvis;
                    rows = SubBlock.GetRows();
                    cols = SubBlock.GetColumns(); 
                    for(i = 0; i < rows; ++i)
                    {
                        for(j = 0; j < cols; ++j)
                        {
                            (*D)(i+k*rows,j+k*cols) = inv_kinvis*SubBlock(i,j);
                        }
                    }
                }
                
                
                // Loop over pressure space and construct boundary block matrices.         
                for(i = 0; i < bmap.num_elements(); ++i)
                {
                    // Fill element with mode
                    Vmath::Zero(ncoeffs,coeffs,1);
                    coeffs[bmap[i]] = 1.0;
                    m_fields[m_velocity[0]]->GetExp(eid)->BwdTrans(coeffs,phys);
                    
                    // Differentiation & Inner product wrt base. 
                    for(j = 0; j < nvel; ++j)
                    {
                        if( (nz_loc == 2)&&(j == 2)) // handle d/dz derivative
                        {
                            NekDouble beta =  -2*M_PI*HomogeneousMode/m_LhomZ;
                            
                            Vmath::Smul(m_fields[m_velocity[0]]->GetExp(eid)->GetTotPoints(), beta, phys,1,deriv,1);
                            
                            m_pressure->GetExp(eid)->IProductWRTBase(deriv,pcoeffs);
                            
                            Blas::Dcopy(psize,&(pcoeffs)[0],1,
                                        Dbnd->GetRawPtr() + 
                                        ((nz_loc*j+1)*bmap.num_elements()+i)*nsize_p[n],1);
                            
                            Vmath::Neg(psize,pcoeffs,1);
                            Blas::Dcopy(psize,&(pcoeffs)[0],1,
                                        Dbnd->GetRawPtr() + 
                                        ((nz_loc*j)*bmap.num_elements()+i)*nsize_p[n]+psize,1);
                            
                        }
                        else
                        {
                            if(j < 2) // required for mean mode of homogeneous expansion 
                            {
                                locExp->PhysDeriv(MultiRegions::DirCartesianMap[j],phys,deriv);		
                                m_pressure->GetExp(eid)->IProductWRTBase(deriv,pcoeffs);
                                // copy into column major storage. 
                                for(k = 0; k < nz_loc; ++k)
                                {
                                    Blas::Dcopy(psize,&(pcoeffs)[0],1,
                                                Dbnd->GetRawPtr() + 
                                                ((nz_loc*j+k)*bmap.num_elements()+i)*nsize_p[n]+ k*psize,1);
                                }
                            }
                        }
                    }
                }
                
                for(i = 0; i < imap.num_elements(); ++i)
                {
                    // Fill element with mode
                    Vmath::Zero(ncoeffs,coeffs,1);
                    coeffs[imap[i]] = 1.0;
                    m_fields[m_velocity[0]]->GetExp(eid)->BwdTrans(coeffs,phys);
                    
                    // Differentiation & Inner product wrt base. 
                    for(j = 0; j < nvel; ++j)
                    {
                        if( (nz_loc == 2)&&(j == 2)) // handle d/dz derivative
                        {
                            NekDouble beta = -2*M_PI*HomogeneousMode/m_LhomZ;
                            
                            Vmath::Smul(m_fields[m_velocity[0]]->GetExp(eid)->GetTotPoints(), beta, phys,1,deriv,1); 
                            
                            m_pressure->GetExp(eid)->IProductWRTBase(deriv,pcoeffs);
                            
                            Blas::Dcopy(psize,&(pcoeffs)[0],1,
                                        Dint->GetRawPtr() + 
                                        ((nz_loc*j+1)*imap.num_elements()+i)*nsize_p[n],1);
                            
                            Vmath::Neg(psize,pcoeffs,1);
                            Blas::Dcopy(psize,&(pcoeffs)[0],1,
                                        Dint->GetRawPtr() + 
                                        ((nz_loc*j)*imap.num_elements()+i)*nsize_p[n]+psize,1);
                            
                        }
                        else
                        {
                            if(j < 2) // required for mean mode of homogeneous expansion 
                            {
                                //m_fields[m_velocity[0]]->GetExp(eid)->PhysDeriv(j,phys, deriv);
                                locExp->PhysDeriv(MultiRegions::DirCartesianMap[j],phys,deriv);
                                
                                m_pressure->GetExp(eid)->IProductWRTBase(deriv,pcoeffs);
                                
                                // copy into column major storage. 
                                for(k = 0; k < nz_loc; ++k)
                                {
                                    Blas::Dcopy(psize,&(pcoeffs)[0],1,
                                                Dint->GetRawPtr() +
                                                ((nz_loc*j+k)*imap.num_elements()+i)*nsize_p[n]+ k*psize,1);
                                }
                            }
                        }
                    }
                }
            }
            else
            {
                // construct velocity matrices and pressure systems at
                // the same time resusing differential of velocity
                // space
                
                DNekScalMat &HelmMat = *(locExp->as<LocalRegions::Expansion>()
                                               ->GetLocMatrix(helmkey));
                DNekScalMatSharedPtr MassMat;
                
                Array<OneD, const NekDouble> HelmMat_data = HelmMat.GetOwnedMatrix()->GetPtr();
                NekDouble HelmMatScale = HelmMat.Scale();
                int HelmMatRows = HelmMat.GetRows();
                
                if((lambda_imag != NekConstants::kNekUnsetDouble)&&(nz_loc == 2))
                {
                    LocalRegions::MatrixKey masskey(StdRegions::eMass,
                                                    locExp->DetShapeType(),
                                                    *locExp);
                    MassMat = locExp->as<LocalRegions::Expansion>()
                                    ->GetLocMatrix(masskey);
                }
                
                Array<OneD, NekDouble> Advtmp;
                Array<OneD, Array<OneD, NekDouble> > AdvDeriv(nvel*nvel);
                // Use ExpList phys array for temporaary storage
                Array<OneD, NekDouble> tmpphys = m_fields[0]->UpdatePhys();
                int phys_offset = m_fields[m_velocity[0]]->GetPhys_Offset(eid);
                int nv;
                int npoints = locExp->GetTotPoints();
                
                // Calculate derivative of base flow 
                if(IsLinearNSEquation)
                {
                    int nv1;
                    int cnt = 0;
                    AdvDeriv[0] = Array<OneD, NekDouble>(nvel*nvel*npoints);
                    for(nv = 0; nv < nvel; ++nv)
                    {
                        for(nv1 = 0; nv1 < nvel; ++nv1)
                        {
                            if(cnt < nvel*nvel-1)
                            {
                                AdvDeriv[cnt+1] = AdvDeriv[cnt] + npoints;
                                ++cnt;
                            }
                            
                            if((nv1 == 2)&&(m_HomogeneousType == eHomogeneous1D))
                            {
                                Vmath::Zero(npoints,AdvDeriv[nv*nvel+nv1],1); // dU/dz = 0
                            }
                            else
                            {
                                locExp->PhysDeriv(MultiRegions::DirCartesianMap[nv1],Advfield[nv] + phys_offset, AdvDeriv[nv*nvel+nv1]);
                            }
                        }
                    }
                }
                
                
                for(i = 0; i < nbmap; ++i)
                {
                    
                    // Fill element with mode
                    Vmath::Zero(ncoeffs,coeffs,1);
                    coeffs[bmap[i]] = 1.0;
                    locExp->BwdTrans(coeffs,phys);
                    
                    for(k = 0; k < nvel*nz_loc; ++k)
                    {
                        for(j = 0; j < nbmap; ++j)
                        {
                            //                            Ah_data[i+k*nbmap + (j+k*nbmap)*AhRows] += m_kinvis*HelmMat(bmap[i],bmap[j]);
                            Ah_data[i+k*nbmap + (j+k*nbmap)*AhRows] += m_kinvis*HelmMatScale*HelmMat_data[bmap[i] + HelmMatRows*bmap[j]];
                        }
                        
                        for(j = 0; j < nimap; ++j)
                        {
                            B_data[i+k*nbmap + (j+k*nimap)*nbndry] += m_kinvis*HelmMatScale*HelmMat_data[bmap[i]+HelmMatRows*imap[j]];
                        }
                    }
                    
                    if((lambda_imag != NekConstants::kNekUnsetDouble)&&(nz_loc == 2))
                    {
                        for(k = 0; k < nvel; ++k)
                        {
                            for(j = 0; j < nbmap; ++j)
                            {
                                Ah_data[i+2*k*nbmap + (j+(2*k+1)*nbmap)*AhRows] -= lambda_imag*(*MassMat)(bmap[i],bmap[j]);
                            }
                            
                            for(j = 0; j < nbmap; ++j)
                            {
                                Ah_data[i+(2*k+1)*nbmap + (j+2*k*nbmap)*AhRows] += lambda_imag*(*MassMat)(bmap[i],bmap[j]);
                            }
                            
                            for(j = 0; j < nimap; ++j)
                            {
                                B_data[i+2*k*nbmap + (j+(2*k+1)*nimap)*nbndry] -= lambda_imag*(*MassMat)(bmap[i],imap[j]);
                            }
                            
                            for(j = 0; j < nimap; ++j)
                            {
                                B_data[i+(2*k+1)*nbmap + (j+2*k*nimap)*nbndry] += lambda_imag*(*MassMat)(bmap[i],imap[j]);
                            }
                            
                        }
                    }
                    
                    
                    
                    for(k = 0; k < nvel; ++k)
                    {
                        if((nz_loc == 2)&&(k == 2)) // handle d/dz derivative
                        { 
                            NekDouble beta = -2*M_PI*HomogeneousMode/m_LhomZ;
                            
                            // Real Component
                            Vmath::Smul(npoints,beta,phys,1,deriv,1);
                            
                            m_pressure->GetExp(eid)->IProductWRTBase(deriv,pcoeffs);
                            Blas::Dcopy(psize,&(pcoeffs)[0],1,
                                        Dbnd->GetRawPtr() + 
                                        ((nz_loc*k+1)*bmap.num_elements()+i)*nsize_p[n],1);
                            
                            // Imaginary Component
                            Vmath::Neg(psize,pcoeffs,1);
                            Blas::Dcopy(psize,&(pcoeffs)[0],1,
                                        Dbnd->GetRawPtr() + 
                                        ((nz_loc*k)*bmap.num_elements()+i)*nsize_p[n]+psize,1);
                            
                            // now do advection terms
                            Vmath::Vmul(npoints, 
                                        Advtmp = Advfield[k] + phys_offset,
                                        1,deriv,1,tmpphys,1);
                            
                            locExp->IProductWRTBase(tmpphys,coeffs);
                            
                            
                            // real contribution
                            for(nv = 0; nv < nvel; ++nv)
                            {
                                for(j = 0; j < nbmap; ++j)
                                {
                                    Ah_data[j+2*nv*nbmap + (i+(2*nv+1)*nbmap)*AhRows] +=
                                    coeffs[bmap[j]];
                                }
                                
                                for(j = 0; j < nimap; ++j)
                                {
                                    C_data[i+(2*nv+1)*nbmap + (j+2*nv*nimap)*nbndry] += 
                                    coeffs[imap[j]];
                                }
                            }
                            
                            Vmath::Neg(ncoeffs,coeffs,1);
                            // imaginary contribution
                            for(nv = 0; nv < nvel; ++nv)
                            {
                                for(j = 0; j < nbmap; ++j)
                                {
                                    Ah_data[j+(2*nv+1)*nbmap + (i+2*nv*nbmap)*AhRows] +=
                                    coeffs[bmap[j]];
                                }
                                
                                for(j = 0; j < nimap; ++j)
                                {
                                    C_data[i+2*nv*nbmap + (j+(2*nv+1)*nimap)*nbndry] += 
                                    coeffs[imap[j]];
                                }
                            }
                        }
                        else
                        {
                            if(k < 2)
                            {
                                locExp->PhysDeriv(MultiRegions::DirCartesianMap[k],phys, deriv);
                                Vmath::Vmul(npoints, 
                                            Advtmp = Advfield[k] + phys_offset,
                                            1,deriv,1,tmpphys,1);
                                locExp->IProductWRTBase(tmpphys,coeffs);
                                
                                
                                for(nv = 0; nv < nvel*nz_loc; ++nv)
                                {
                                    for(j = 0; j < nbmap; ++j)
                                    {
                                        Ah_data[j+nv*nbmap + (i+nv*nbmap)*AhRows] +=
                                        coeffs[bmap[j]];
                                    }
                                    
                                    for(j = 0; j < nimap; ++j)
                                    {
                                        C_data[i+nv*nbmap + (j+nv*nimap)*nbndry] += 
                                        coeffs[imap[j]];
                                    }
                                }
                                
                                // copy into column major storage. 
                                m_pressure->GetExp(eid)->IProductWRTBase(deriv,pcoeffs);
                                for(j = 0; j < nz_loc; ++j)
                                {
                                    Blas::Dcopy(psize,&(pcoeffs)[0],1,
                                                Dbnd->GetRawPtr() + 
                                                ((nz_loc*k+j)*bmap.num_elements() + i)*nsize_p[n]+ j*psize,1);
                                }
                            }
                        }
                        
                        if(IsLinearNSEquation)
                        {
                            for(nv = 0; nv < nvel; ++nv)
                            {
                                // u' . Grad U terms 
                                Vmath::Vmul(npoints,phys,1,
                                            AdvDeriv[k*nvel+nv],
                                            1,tmpphys,1);
                                locExp->IProductWRTBase(tmpphys,coeffs);
                                
                                for(int n1 = 0; n1 < nz_loc; ++n1)
                                {
                                    for(j = 0; j < nbmap; ++j)
                                    {
                                        Ah_data[j+(k*nz_loc+n1)*nbmap + 
                                        (i+(nv*nz_loc+n1)*nbmap)*AhRows] +=
                                        coeffs[bmap[j]];
                                    }
                                    
                                    for(j = 0; j < nimap; ++j)
                                    {
                                        C_data[i+(nv*nz_loc+n1)*nbmap + 
                                        (j+(k*nz_loc+n1)*nimap)*nbndry] += 
                                        coeffs[imap[j]];
                                    }
                                }
                            }                            
                        }
                    }
                }
                
                
                for(i = 0; i < nimap; ++i)
                {
                    // Fill element with mode
                    Vmath::Zero(ncoeffs,coeffs,1);
                    coeffs[imap[i]] = 1.0;
                    locExp->BwdTrans(coeffs,phys);
                    
                    for(k = 0; k < nvel*nz_loc; ++k)
                    {
                        for(j = 0; j < nbmap; ++j) // C set up as transpose
                        {
                            C_data[j+k*nbmap + (i+k*nimap)*nbndry] += m_kinvis*HelmMatScale*HelmMat_data[imap[i]+HelmMatRows*bmap[j]];
                        }
                        
                        for(j = 0; j < nimap; ++j)
                        {
                            D_data[i+k*nimap + (j+k*nimap)*nint] += m_kinvis*HelmMatScale*HelmMat_data[imap[i]+HelmMatRows*imap[j]];
                        }
                    }
                    
                    if((lambda_imag != NekConstants::kNekUnsetDouble)&&(nz_loc == 2))
                    {
                        for(k = 0; k < nvel; ++k)
                        {
                            for(j = 0; j < nbmap; ++j) // C set up as transpose
                            {
                                C_data[j+2*k*nbmap + (i+(2*k+1)*nimap)*nbndry] += lambda_imag*(*MassMat)(bmap[j],imap[i]);
                            }
                            
                            for(j = 0; j < nbmap; ++j) // C set up as transpose
                            {
                                C_data[j+(2*k+1)*nbmap + (i+2*k*nimap)*nbndry] -= lambda_imag*(*MassMat)(bmap[j],imap[i]);
                            }
                            
                            for(j = 0; j < nimap; ++j)
                            {
                                D_data[i+2*k*nimap + (j+(2*k+1)*nimap)*nint] -= lambda_imag*(*MassMat)(imap[i],imap[j]);
                            }
                            
                            for(j = 0; j < nimap; ++j)
                            {
                                D_data[i+(2*k+1)*nimap + (j+2*k*nimap)*nint] += lambda_imag*(*MassMat)(imap[i],imap[j]);
                            }
                        }
                    }
                    
                    
                    for(k = 0; k < nvel; ++k)
                    {
                        if((nz_loc == 2)&&(k == 2)) // handle d/dz derivative
                        { 
                            NekDouble beta = -2*M_PI*HomogeneousMode/m_LhomZ;
                            
                            // Real Component
                            Vmath::Smul(npoints,beta,phys,1,deriv,1);
                            m_pressure->GetExp(eid)->IProductWRTBase(deriv,pcoeffs);
                            Blas::Dcopy(psize,&(pcoeffs)[0],1,
                                        Dint->GetRawPtr() + 
                                        ((nz_loc*k+1)*imap.num_elements()+i)*nsize_p[n],1);
                            // Imaginary Component
                            Vmath::Neg(psize,pcoeffs,1);
                            Blas::Dcopy(psize,&(pcoeffs)[0],1,
                                        Dint->GetRawPtr() + 
                                        ((nz_loc*k)*imap.num_elements()+i)*nsize_p[n]+psize,1);
                            
                            // Advfield[k] *d/dx_k to all velocity
                            // components on diagonal
                            Vmath::Vmul(npoints, Advtmp = Advfield[k] + phys_offset,1,deriv,1,tmpphys,1);
                            locExp->IProductWRTBase(tmpphys,coeffs);
                            
                            // Real Components
                            for(nv = 0; nv < nvel; ++nv)
                            {
                                for(j = 0; j < nbmap; ++j)
                                {
                                    B_data[j+2*nv*nbmap + (i+(2*nv+1)*nimap)*nbndry] += 
                                    coeffs[bmap[j]];
                                }
                                
                                for(j = 0; j < nimap; ++j)
                                {
                                    D_data[j+2*nv*nimap + (i+(2*nv+1)*nimap)*nint] += 
                                    coeffs[imap[j]];
                                }
                            }
                            Vmath::Neg(ncoeffs,coeffs,1);
                            // Imaginary 
                            for(nv = 0; nv < nvel; ++nv)
                            {
                                for(j = 0; j < nbmap; ++j)
                                {
                                    B_data[j+(2*nv+1)*nbmap + (i+2*nv*nimap)*nbndry] += 
                                    coeffs[bmap[j]];
                                }
                                
                                for(j = 0; j < nimap; ++j)
                                {
                                    D_data[j+(2*nv+1)*nimap + (i+2*nv*nimap)*nint] += 
                                    coeffs[imap[j]];
                                }
                            }
                            
                        }
                        else
                        {
                            if(k < 2)
                            {
                                // Differentiation & Inner product wrt base. 
                                //locExp->PhysDeriv(k,phys, deriv);
                                locExp->PhysDeriv(MultiRegions::DirCartesianMap[k],phys,deriv);
                                Vmath::Vmul(npoints, 
                                            Advtmp = Advfield[k] + phys_offset,
                                            1,deriv,1,tmpphys,1);
                                locExp->IProductWRTBase(tmpphys,coeffs);
                                
                                
                                for(nv = 0; nv < nvel*nz_loc; ++nv)
                                {
                                    for(j = 0; j < nbmap; ++j)
                                    {
                                        B_data[j+nv*nbmap + (i+nv*nimap)*nbndry] +=
                                        coeffs[bmap[j]];
                                    }
                                    
                                    for(j = 0; j < nimap; ++j)
                                    {
                                        D_data[j+nv*nimap + (i+nv*nimap)*nint] += 
                                        coeffs[imap[j]];
                                    }
                                }
                                // copy into column major storage. 
                                m_pressure->GetExp(eid)->IProductWRTBase(deriv,pcoeffs);
                                for(j = 0; j < nz_loc; ++j)
                                {
                                    Blas::Dcopy(psize,&(pcoeffs)[0],1,
                                                Dint->GetRawPtr() + 
                                                ((nz_loc*k+j)*imap.num_elements() + i)*nsize_p[n]+j*psize,1);
                                }
                            }
                        }
                        
                        if(IsLinearNSEquation)
                        {
                            int n1;
                            for(nv = 0; nv < nvel; ++nv)
                            {
                                // u'.Grad U terms 
                                Vmath::Vmul(npoints,phys,1, 
                                            AdvDeriv[k*nvel+nv],
                                            1,tmpphys,1);
                                locExp->IProductWRTBase(tmpphys,coeffs);
                                
                                for(n1 = 0; n1 < nz_loc; ++n1)
                                {
                                    for(j = 0; j < nbmap; ++j)
                                    {
                                        B_data[j+(k*nz_loc+n1)*nbmap + 
                                        (i+(nv*nz_loc+n1)*nimap)*nbndry] += 
                                        coeffs[bmap[j]];
                                    }
                                    
                                    for(j = 0; j < nimap; ++j)
                                    {
                                        D_data[j+(k*nz_loc+n1)*nimap +  
                                        (i+(nv*nz_loc+n1)*nimap)*nint] += 
                                        coeffs[imap[j]];
                                    }
                                }
                            }
                        }
                    }
                }
                
                
                D->Invert();
                (*B) = (*B)*(*D);
                
                
                // perform (*Ah) = (*Ah) - (*B)*(*C) but since size of
                // Ah is larger than (*B)*(*C) easier to call blas
                // directly
                Blas::Dgemm('N','T', B->GetRows(), C->GetRows(), 
                            B->GetColumns(), -1.0, B->GetRawPtr(),
                            B->GetRows(), C->GetRawPtr(), 
                            C->GetRows(), 1.0, 
                            Ah->GetRawPtr(), Ah->GetRows());
            }
            
            double norm = 1, norm_i, scale_factor = 1;
           /* if(deflate)
            {
				for(int j = 0; j < local_indices_to_be_continued.size(); j++)
				{
					norm_i=0;
					int curr_j = local_indices_to_be_continued[j];
					for(int i = 0; i < sol_x_cont_defl[curr_j].num_elements(); i++)  //L2 norm
					{
						//norm_i += (sol_x_cont_defl[curr_j][i] - Advfield[0][i]) * (sol_x_cont_defl[curr_j][i] - Advfield[0][i]);
						//norm_i += (sol_y_cont_defl[curr_j][i] - Advfield[1][i]) * (sol_y_cont_defl[curr_j][i] - Advfield[1][i]);
						norm_i += (sol_x_cont_defl[curr_j][i] - sol_x_cont_defl[total_solutions_found][i]) 
								* (sol_x_cont_defl[curr_j][i] - sol_x_cont_defl[total_solutions_found][i]);
						norm_i += (sol_y_cont_defl[curr_j][i] - sol_y_cont_defl[total_solutions_found][i]) 
								* (sol_y_cont_defl[curr_j][i] - sol_y_cont_defl[total_solutions_found][i]);
					}  
					
					norm_i = sqrt(norm_i);///sol_x_cont_defl[curr_j].num_elements();
					
					norm_i = 1+1/norm_i;
					norm *= norm_i;
					
					//cout<<norm_i<<" --> "<<norm<<endl;
				
					//norm_i += 1e-13;
					//if(norm_i < norm)
					//	norm = norm_i;
				}
				scale_factor = norm;//(1+1/norm);
				//cout<<"The norm is "<<norm<<endl;    
            	//cout<<endl<<endl;   
            } */
            mat.m_BCinv->SetBlock(n,n,loc_mat = MemoryManager<DNekScalMat>::AllocateSharedPtr(one,B));
            mat.m_Btilde->SetBlock(n,n,loc_mat = MemoryManager<DNekScalMat>::AllocateSharedPtr(one,C));
            mat.m_Cinv->SetBlock(n,n,loc_mat = MemoryManager<DNekScalMat>::AllocateSharedPtr(one,D));
            mat.m_D_bnd->SetBlock(n,n,loc_mat = MemoryManager<DNekScalMat>::AllocateSharedPtr(one, Dbnd));
            mat.m_D_int->SetBlock(n,n,loc_mat = MemoryManager<DNekScalMat>::AllocateSharedPtr(one, Dint));
            
            // Do matrix manipulations and get final set of block matries    
            // reset boundary to put mean mode into boundary system. 
            
            DNekMatSharedPtr Cinv,BCinv,Btilde; 
            DNekMat  DintCinvDTint, BCinvDTint_m_DTbnd, DintCinvBTtilde_m_Dbnd;
            
            Cinv   = D;
            BCinv  = B;  
            Btilde = C; 
            
            DintCinvDTint      = (*Dint)*(*Cinv)*Transpose(*Dint);
            BCinvDTint_m_DTbnd = (*BCinv)*Transpose(*Dint) - Transpose(*Dbnd);
            
            // This could be transpose of BCinvDint in some cases
            DintCinvBTtilde_m_Dbnd = (*Dint)*(*Cinv)*Transpose(*Btilde) - (*Dbnd); 
            
            // Set up final set of matrices. 
            DNekMatSharedPtr Bh = MemoryManager<DNekMat>::AllocateSharedPtr(nsize_bndry_p1[n],nsize_p_m1[n],zero);
            DNekMatSharedPtr Ch = MemoryManager<DNekMat>::AllocateSharedPtr(nsize_p_m1[n],nsize_bndry_p1[n],zero);
            DNekMatSharedPtr Dh = MemoryManager<DNekMat>::AllocateSharedPtr(nsize_p_m1[n], nsize_p_m1[n],zero);
            Array<OneD, NekDouble> Dh_data = Dh->GetPtr();
            
            // Copy matrices into final structures. 
            int n1,n2;
            for(n1 = 0; n1 < nz_loc; ++n1)
            {
                for(i = 0; i < psize-1; ++i)
                {
                    for(n2 = 0; n2 < nz_loc; ++n2)
                    {
                        for(j = 0; j < psize-1; ++j)
                        {
                            //(*Dh)(i+n1*(psize-1),j+n2*(psize-1)) = 
                            //-DintCinvDTint(i+1+n1*psize,j+1+n2*psize);
                            Dh_data[(i+n1*(psize-1)) + (j+n2*(psize-1))*Dh->GetRows()] = -DintCinvDTint(i+1+n1*psize,j+1+n2*psize) * scale_factor;
                        }
                    }                    
                }
            }
            
            for(n1 = 0; n1 < nz_loc; ++n1)
            {
                for(i = 0; i < nsize_bndry_p1[n]-nz_loc; ++i)
                {
                    (*Ah)(i,nsize_bndry_p1[n]-nz_loc+n1) = BCinvDTint_m_DTbnd(i,n1*psize) * scale_factor;
                    (*Ah)(nsize_bndry_p1[n]-nz_loc+n1,i) = DintCinvBTtilde_m_Dbnd(n1*psize,i) * scale_factor;
                }
            }
            
            for(n1 = 0; n1 < nz_loc; ++n1)
            {
                for(n2 = 0; n2 < nz_loc; ++n2)
                {
                    (*Ah)(nsize_bndry_p1[n]-nz_loc+n1,nsize_bndry_p1[n]-nz_loc+n2) = -DintCinvDTint(n1*psize,n2*psize) * scale_factor;
                }
            }
            
            for(n1 = 0; n1 < nz_loc; ++n1)
            {
                for(j = 0; j < psize-1; ++j)
                {
                    for(i = 0; i < nsize_bndry_p1[n]-nz_loc; ++i)
                    {
                        (*Bh)(i,j+n1*(psize-1)) = BCinvDTint_m_DTbnd(i,j+1+n1*psize) * scale_factor;
                        (*Ch)(j+n1*(psize-1),i) = DintCinvBTtilde_m_Dbnd(j+1+n1*psize,i) * scale_factor;
                    }
                }
            }
            
            for(n1 = 0; n1 < nz_loc; ++n1)
            {
                for(n2 = 0; n2 < nz_loc; ++n2)
                {
                    for(j = 0; j < psize-1; ++j)
                    {
                        (*Bh)(nsize_bndry_p1[n]-nz_loc+n1,j+n2*(psize-1)) = -DintCinvDTint(n1*psize,j+1+n2*psize) * scale_factor;
                        (*Ch)(j+n2*(psize-1),nsize_bndry_p1[n]-nz_loc+n1) = -DintCinvDTint(j+1+n2*psize,n1*psize) * scale_factor;
                    }
                }
            }
            
            // Do static condensation
            Dh->Invert();
            (*Bh) = (*Bh)*(*Dh);
            //(*Ah) = (*Ah) - (*Bh)*(*Ch);
            Blas::Dgemm('N','N', Bh->GetRows(), Ch->GetColumns(), Bh->GetColumns(), -1.0,
                        Bh->GetRawPtr(), Bh->GetRows(), Ch->GetRawPtr(), Ch->GetRows(), 
                        1.0, Ah->GetRawPtr(), Ah->GetRows());
            
            // Set matrices for later inversion. Probably do not need to be 
            // attached to class
            pAh->SetBlock(n,n,loc_mat = MemoryManager<DNekScalMat>::AllocateSharedPtr(one,Ah));
            pBh->SetBlock(n,n,loc_mat = MemoryManager<DNekScalMat>::AllocateSharedPtr(one,Bh));
            pCh->SetBlock(n,n,loc_mat = MemoryManager<DNekScalMat>::AllocateSharedPtr(one,Ch));
            pDh->SetBlock(n,n,loc_mat = MemoryManager<DNekScalMat>::AllocateSharedPtr(one,Dh));    
        }
        timer.Stop();
 //      cout << "Matrix Setup Costs: " << timer.TimePerTest(1) << endl;
        
        timer.Start();
        // Set up global coupled boundary solver. 
        // This is a key to define the solution matrix type
        // currently we are giving it a argument of eLInearAdvectionReaction 
        // since this then makes the matrix storage of type eFull
        MultiRegions::GlobalLinSysKey key(StdRegions::eLinearAdvectionReaction,locToGloMap);
        mat.m_CoupledBndSys = MemoryManager<MultiRegions::GlobalLinSysDirectStaticCond>::AllocateSharedPtr(key,m_fields[0],pAh,pBh,pCh,pDh,locToGloMap);
        mat.m_CoupledBndSys->Initialise(locToGloMap);
        timer.Stop();
//        cout << "Multilevel condensation: " << timer.TimePerTest(1) << endl;
    }
    
    void CoupledLinearNS_trafoP::v_GenerateSummary(SolverUtils::SummaryList& s)
    {
        SolverUtils::AddSummaryItem(s, "Solver Type", "Coupled Linearised NS");
    }
    
    void CoupledLinearNS_trafoP::v_DoInitialise(void)
    {
        switch(m_equationType)
        {
            case eUnsteadyStokes:
            case eUnsteadyNavierStokes:
            {
                
//                LibUtilities::TimeIntegrationMethod intMethod;
//                std::string TimeIntStr = m_session->GetSolverInfo("TIMEINTEGRATIONMETHOD");
//                int i;
//                for(i = 0; i < (int) LibUtilities::SIZE_TimeIntegrationMethod; ++i)
//                {
//                    if(boost::iequals(LibUtilities::TimeIntegrationMethodMap[i],TimeIntStr))
//                    {
//                        intMethod = (LibUtilities::TimeIntegrationMethod)i;
//                        break;
//                    }
//                }
//
//                ASSERTL0(i != (int) LibUtilities::SIZE_TimeIntegrationMethod, "Invalid time integration type.");
//
//                m_integrationScheme = LibUtilities::GetTimeIntegrationWrapperFactory().CreateInstance(LibUtilities::TimeIntegrationMethodMap[intMethod]);
                
                // Could defind this from IncNavierStokes class? 
                m_ode.DefineOdeRhs(&CoupledLinearNS_trafoP::EvaluateAdvection, this);
                
                m_ode.DefineImplicitSolve(&CoupledLinearNS_trafoP::SolveUnsteadyStokesSystem,this);
                
                // Set initial condition using time t=0
                
                SetInitialConditions(0.0);
                
            }
        case eSteadyStokes:
            SetUpCoupledMatrix(0.0);
            break;
        case eSteadyOseen:
            {
                Array<OneD, Array<OneD, NekDouble> > AdvField(m_velocity.num_elements());
                for(int i = 0; i < m_velocity.num_elements(); ++i)
                {
                    AdvField[i] = Array<OneD, NekDouble> (m_fields[m_velocity[i]]->GetTotPoints(),0.0);
                }
                
                ASSERTL0(m_session->DefinesFunction("AdvectionVelocity"),
                         "Advection Velocity section must be defined in "
                         "session file.");
                
                std::vector<std::string> fieldStr;
                for(int i = 0; i < m_velocity.num_elements(); ++i)
                {
                    fieldStr.push_back(m_boundaryConditions->GetVariable(m_velocity[i]));
                }
                EvaluateFunction(fieldStr,AdvField,"AdvectionVelocity");
                
                SetUpCoupledMatrix(0.0,AdvField,false); //changed to true to use the full equation
            }
            break;
        case eSteadyNavierStokes:
            {			
                m_session->LoadParameter("KinvisMin", m_kinvisMin);
                m_session->LoadParameter("KinvisPercentage", m_KinvisPercentage);
                m_session->LoadParameter("Tolerance", m_tol);
                m_session->LoadParameter("MaxIteration", m_maxIt);
                m_session->LoadParameter("MatrixSetUpStep", m_MatrixSetUpStep);
                m_session->LoadParameter("Restart", m_Restart);
                
                
                DefineForcingTerm();
                
                if (m_Restart == 1)
                {
                    ASSERTL0(m_session->DefinesFunction("Restart"),
                             "Restart section must be defined in session file.");
                    
                    Array<OneD, Array<OneD, NekDouble> > Restart(m_velocity.num_elements());
                    for(int i = 0; i < m_velocity.num_elements(); ++i)
                    {
                        Restart[i] = Array<OneD, NekDouble> (m_fields[m_velocity[i]]->GetTotPoints(),0.0);
                    }
                    std::vector<std::string> fieldStr;
                    for(int i = 0; i < m_velocity.num_elements(); ++i)
                    {
                        fieldStr.push_back(m_boundaryConditions->GetVariable(m_velocity[i]));
                    }
                    EvaluateFunction(fieldStr, Restart, "Restart");
                    
                    for(int i = 0; i < m_velocity.num_elements(); ++i)
                    {
                        m_fields[m_velocity[i]]->FwdTrans_IterPerExp(Restart[i], m_fields[m_velocity[i]]->UpdateCoeffs());
                    }
                    cout << "Saving the RESTART file for m_kinvis = "<< m_kinvis << " (<=> Re = " << 1/m_kinvis << ")" <<endl;
                }
                else //We solve the Stokes Problem
                {
                    
                    /*Array<OneD, Array<OneD, NekDouble> >ZERO(m_velocity.num_elements());
                     *					
                     *					for(int i = 0; i < m_velocity.num_elements(); ++i)
                     *					{				
                     *						ZERO[i] = Array<OneD, NekDouble> (m_fields[m_velocity[i]]->GetTotPoints(),0.0);
                     *						m_fields[m_velocity[i]]->FwdTrans(ZERO[i], m_fields[m_velocity[i]]->UpdateCoeffs());
                     }*/
                    
                    SetUpCoupledMatrix(0.0);						
                    m_initialStep = true;
                    m_counter=1;
                    //SolveLinearNS(m_ForcingTerm_Coeffs);
                    Solve();
                    m_initialStep = false;
                    cout << "Saving the Stokes Flow for m_kinvis = "<< m_kinvis << " (<=> Re = " << 1/m_kinvis << ")" <<endl;
                }
            }
            break;
        case eSteadyLinearisedNS:
            {                
                SetInitialConditions(0.0);
                
                Array<OneD, Array<OneD, NekDouble> > AdvField(m_velocity.num_elements());
                for(int i = 0; i < m_velocity.num_elements(); ++i)
                {
                    AdvField[i] = Array<OneD, NekDouble> (m_fields[m_velocity[i]]->GetTotPoints(),0.0);
                }
                
                ASSERTL0(m_session->DefinesFunction("AdvectionVelocity"),
                         "Advection Velocity section must be defined in "
                         "session file.");
                
                std::vector<std::string> fieldStr;
                for(int i = 0; i < m_velocity.num_elements(); ++i)
                {
                    fieldStr.push_back(m_boundaryConditions->GetVariable(m_velocity[i]));
                }
                EvaluateFunction(fieldStr,AdvField,"AdvectionVelocity");
                
                SetUpCoupledMatrix(m_lambda,AdvField,true);
            }
            break;
        case eNoEquationType:
        default:
            ASSERTL0(false,"Unknown or undefined equation type for CoupledLinearNS_trafoP");
        }
    }
    
    void CoupledLinearNS_trafoP::EvaluateAdvection(const Array<OneD, const Array<OneD, NekDouble> > &inarray, 
                                            Array<OneD, Array<OneD, NekDouble> > &outarray,
                                            const NekDouble time)
    {  	    
        // evaluate convection terms
        EvaluateAdvectionTerms(inarray,outarray);

        std::vector<SolverUtils::ForcingSharedPtr>::const_iterator x;
        for (x = m_forcing.begin(); x != m_forcing.end(); ++x)
        {
            (*x)->Apply(m_fields, outarray, outarray, time);
        }
    }
    
    void CoupledLinearNS_trafoP::SolveUnsteadyStokesSystem(const Array<OneD, const Array<OneD, NekDouble> > &inarray, 
                                                    Array<OneD, Array<OneD, NekDouble> > &outarray, 
                                                    const NekDouble time, 
                                                    const NekDouble aii_Dt)
    {
        int i;
        Array<OneD, Array< OneD, NekDouble> > F(m_nConvectiveFields);
        NekDouble  lambda = 1.0/aii_Dt; 
        static NekDouble lambda_store; 
        Array <OneD, Array<OneD, NekDouble> > forcing(m_velocity.num_elements());
        // Matrix solution
        if(fabs(lambda_store - lambda) > 1e-10)
        {
            cout << "Setting up Stokes matrix problem [.";
            fflush(stdout);
            SetUpCoupledMatrix(lambda);
            cout << "]" << endl;
            lambda_store = lambda;
        }
        
        // Forcing for advection solve 
        for(i = 0; i < m_velocity.num_elements(); ++i)
        {
            bool waveSpace = m_fields[m_velocity[i]]->GetWaveSpace();
            m_fields[m_velocity[i]]->SetWaveSpace(true);
            m_fields[m_velocity[i]]->IProductWRTBase(inarray[i],m_fields[m_velocity[i]]->UpdateCoeffs());
            m_fields[m_velocity[i]]->SetWaveSpace(waveSpace);
            Vmath::Smul(m_fields[m_velocity[i]]->GetNcoeffs(),lambda,m_fields[m_velocity[i]]->GetCoeffs(), 1,m_fields[m_velocity[i]]->UpdateCoeffs(),1);
            forcing[i] = m_fields[m_velocity[i]]->GetCoeffs();
        }
        
        SolveLinearNS(forcing);
        
        for(i = 0; i < m_velocity.num_elements(); ++i)
        {
            m_fields[m_velocity[i]]->BwdTrans(m_fields[m_velocity[i]]->GetCoeffs(),outarray[i]);
        }
    }
    
    
    void CoupledLinearNS_trafoP::v_TransCoeffToPhys(void)
    {
        int nfields = m_fields.num_elements();
        for (int k=0 ; k < nfields; ++k)
        {
            //Backward Transformation in physical space for time evolution
            m_fields[k]->BwdTrans_IterPerExp(m_fields[k]->GetCoeffs(),
                                             m_fields[k]->UpdatePhys());
        }
        
    }
    
    void CoupledLinearNS_trafoP::v_TransPhysToCoeff(void)
    {
        int nfields = m_fields.num_elements();
        for (int k=0 ; k < nfields; ++k)
        {
            //Forward Transformation in physical space for time evolution
            m_fields[k]->FwdTrans_IterPerExp(m_fields[k]->GetPhys(),
                                             m_fields[k]->UpdateCoeffs());
            
        }
    }

    NekDouble CoupledLinearNS_trafoP::Get_m_kinvis(void)
    {
	return m_kinvis;
    }

    void CoupledLinearNS_trafoP::Set_m_kinvis(NekDouble input)
    {
	m_kinvis = input;
    }
    
    Array<OneD, Array<OneD, NekDouble> > CoupledLinearNS_trafoP::DoSolve_at_param(Array<OneD, NekDouble> init_snapshot_x, Array<OneD, NekDouble> init_snapshot_y, NekDouble parameter)
	{
		//	DoInitialise();
		//	DoSolve();
		double rel_err = 1.0;
		while (rel_err > 1e-8)
		{
			Set_m_kinvis( parameter );
			DoInitialiseAdv(init_snapshot_x, init_snapshot_y); // replaces .DoInitialise();
			DoSolve();
			// compare the accuracy
			Array<OneD, MultiRegions::ExpListSharedPtr> m_fields_t = UpdateFields();
			m_fields_t[0]->BwdTrans(m_fields_t[0]->GetCoeffs(), m_fields_t[0]->UpdatePhys());
			m_fields_t[1]->BwdTrans(m_fields_t[1]->GetCoeffs(), m_fields_t[1]->UpdatePhys());
			Array<OneD, NekDouble> out_field_trafo_x(GetNpoints(), 0.0);
			Array<OneD, NekDouble> out_field_trafo_y(GetNpoints(), 0.0);
		
			Eigen::VectorXd csx0_trafo(GetNpoints());
			Eigen::VectorXd csy0_trafo(GetNpoints());
			Eigen::VectorXd csx0(GetNpoints());
			Eigen::VectorXd csy0(GetNpoints());
		
			CopyFromPhysField(0, out_field_trafo_x); 
			CopyFromPhysField(1, out_field_trafo_y);
		
			for( int index_conv = 0; index_conv < GetNpoints(); ++index_conv)
			{
				csx0_trafo(index_conv) = out_field_trafo_x[index_conv];
				csy0_trafo(index_conv) = out_field_trafo_y[index_conv];
				csx0(index_conv) = init_snapshot_x[index_conv];
				csy0(index_conv) = init_snapshot_y[index_conv];
			}
		
		//		cout << "csx0.norm() " << csx0.norm() << endl;
		//		cout << "csx0_trafo.norm() " << csx0_trafo.norm() << endl;
		//		cout << "csy0.norm() " << csy0.norm() << endl;
		//		cout << "csy0_trafo.norm() " << csy0_trafo.norm() << endl;
			//rel_err = std::abs(csx0_trafo.norm() - csx0.norm()) / csx0.norm() + std::abs(csy0_trafo.norm() - csy0.norm()) / csy0.norm();
			rel_err = (csx0_trafo - csx0).norm() / csx0.norm() + (csy0_trafo - csy0).norm() / csy0.norm();
		//		cout << "rel_err " << rel_err << endl;
		
			init_snapshot_x = out_field_trafo_x;
			init_snapshot_y = out_field_trafo_y;
		}
		
		
		
		Array<OneD, Array<OneD, NekDouble> > converged_solution( 2 );
		converged_solution[0] = Array<OneD, NekDouble>(GetNpoints(), 0.0);
		converged_solution[1] = Array<OneD, NekDouble>(GetNpoints(), 0.0);
		converged_solution[0] = init_snapshot_x;
		converged_solution[1] = init_snapshot_y;
		
		//	cout << " curr_f_bnd.size()+curr_f_int.size() " <<  curr_f_bnd.size()+curr_f_int.size() << endl;
		//	cout << " GetNcoeffs() " <<  GetNcoeffs() << endl;
		
		return converged_solution;
	}

    Array<OneD, Array<OneD, NekDouble> > CoupledLinearNS_trafoP::DoSolve_at_param_continuation(Array<OneD, NekDouble> init_snapshot_x, Array<OneD, NekDouble> init_snapshot_y, NekDouble parameter)
    {
	double rel_err = 1.0, use_heuristic = true;
	int iterations = 0, max_iterations = 150;
	bool change_method = use_Newton;
	
	if(start_with_Oseen)
		use_Newton = false;
		
	Array<OneD, MultiRegions::ExpListSharedPtr> m_fields_t;
	
	if(total_solutions_found>1)
	{
		sol_x_cont_defl[total_solutions_found] = init_snapshot_x;
		sol_y_cont_defl[total_solutions_found] = init_snapshot_y;	
	}
	
	double last_tau = 0, strength = 1, norm_i, norm_ix, norm_iy, norm_0, norm_0x, norm_0y;
	Timer timer;
	
	while (rel_err > 1e-10 && (iterations < max_iterations || !use_deflation))
	{
        timer.Start();
		Set_m_kinvis( parameter );
		DoInitialiseAdv(init_snapshot_x, init_snapshot_y); // replaces .DoInitialise();
		DoSolve();
		// compare the accuracy
		m_fields_t = UpdateFields();
		m_fields_t[0]->BwdTrans(m_fields_t[0]->GetCoeffs(), m_fields_t[0]->UpdatePhys());
		m_fields_t[1]->BwdTrans(m_fields_t[1]->GetCoeffs(), m_fields_t[1]->UpdatePhys());
		Array<OneD, NekDouble> out_field_trafo_x(GetNpoints(), 0.0);
		Array<OneD, NekDouble> out_field_trafo_y(GetNpoints(), 0.0);
		Array<OneD, NekDouble> diff_x(GetNpoints(), 0.0);
		Array<OneD, NekDouble> diff_y(GetNpoints(), 0.0);

		Array<OneD, NekDouble> last_out_field_trafo_x(GetNpoints(), 0.0);
		Array<OneD, NekDouble> last_out_field_trafo_y(GetNpoints(), 0.0);
		
		Eigen::VectorXd csx0_trafo(GetNpoints());
		Eigen::VectorXd csy0_trafo(GetNpoints());
		Eigen::VectorXd csx0(GetNpoints());
		Eigen::VectorXd csy0(GetNpoints());
		

		CopyFromPhysField(0, out_field_trafo_x); 
		CopyFromPhysField(1, out_field_trafo_y);

		for( int index_conv = 0; index_conv < GetNpoints(); ++index_conv)
		{
			csx0_trafo(index_conv) = out_field_trafo_x[index_conv];
			csy0_trafo(index_conv) = out_field_trafo_y[index_conv];
			csx0(index_conv) = init_snapshot_x[index_conv];
			csy0(index_conv) = init_snapshot_y[index_conv];
		}

//		cout << "csx0.norm() " << csx0.norm() << endl;
//		cout << "csx0_trafo.norm() " << csx0_trafo.norm() << endl;
//		cout << "csy0.norm() " << csy0.norm() << endl;
//		cout << "csy0_trafo.norm() " << csy0_trafo.norm() << endl;
		

		// to use a better error estimate use the first rel_err, I need it to obtain converge with higher order polynomials
		Vmath::Vsub(out_field_trafo_x.num_elements(), out_field_trafo_x, 1, init_snapshot_x, 1, diff_x, 1);
		Vmath::Vsub(out_field_trafo_y.num_elements(), out_field_trafo_y, 1, init_snapshot_y, 1, diff_y, 1);
		norm_ix = m_fields[0]->L2(diff_x);
		norm_iy = m_fields[1]->L2(diff_y);
		norm_i = sqrt(norm_ix*norm_ix + norm_iy*norm_iy);
		norm_0x = m_fields[0]->L2(init_snapshot_x);
		norm_0y = m_fields[1]->L2(init_snapshot_y);
		norm_0 = sqrt(norm_0x*norm_0x + norm_0y*norm_0y);
		rel_err = norm_i / (norm_0+1e-16);
		//rel_err = (csx0_trafo - csx0).norm() / csx0.norm() + (csy0_trafo - csy0).norm() / csy0.norm();
		
		iterations++;
		if (snapshot_computation_plot_rel_errors)
		{
			if((iterations)%1==0)   // if one doesn't want to have the screen filled with errors but sometimes one is necessary
				cout <<"rel_err " << rel_err << endl;
		}
			
		if(deflate)
        { 
        	double norm_0, tau = 2, tau_i = 1, scal_product, M_inv, norm_max = 0;
        	int power = 1, nvel = sol_x_cont_defl[0].num_elements();
        	bool danger = false, far_from_everything = true;
			for(int j = 0; j < local_indices_to_be_continued.size(); j++)
			{
				norm_i = 0;
				int curr_j = local_indices_to_be_continued[j];
				
				Vmath::Vsub(out_field_trafo_x.num_elements(), out_field_trafo_x, 1, sol_x_cont_defl[curr_j], 1, diff_x, 1);
				Vmath::Vsub(out_field_trafo_y.num_elements(), out_field_trafo_y, 1, sol_y_cont_defl[curr_j], 1, diff_y, 1);
				norm_ix = m_fields[0]->L2(diff_x);
				norm_iy = m_fields[1]->L2(diff_y);
				norm_i = sqrt(norm_ix*norm_ix + norm_iy*norm_iy);
						
				if(norm_i < 1e2)   
					far_from_everything = false;
				if(norm_i < 1e-2) 
					danger = true;
				
				if(norm_i > 1e15) // to avoid the useless remaining iterations
					iterations = 99999;
					
				if(change_method && norm_i > 1e3) // try to avoid divergence using some Oseen steps
				{
					if(last_tau < -9.9)
					{
						Vmath::Vcopy(out_field_trafo_x.num_elements(), last_out_field_trafo_x, 1, out_field_trafo_x, 1 );
						Vmath::Vcopy(out_field_trafo_y.num_elements(), last_out_field_trafo_y, 1, out_field_trafo_y, 1 );
						use_heuristic = false;
					}
					else
					{
						use_Newton = false;
					}
				}
				if(change_method && rel_err < 1e-2) // use again Newton if you are converging
					use_Newton = true;
				
				cout<<"norm_i "<<norm_i<<endl;
				
				if(power == 1)	// deflate with power 1 or 2
				{
					M_inv = 1/(1 + 1/norm_i);  
					norm_i = norm_i*norm_i*norm_i;  
				}
				else
				{
					if(power==2)
					{
						M_inv = 1/(1+1/norm_i/norm_i);  
						norm_i = norm_i*norm_i*norm_i*norm_i;
					}
					else //to try with a general power
					{
						double norm_ip = 1;
						for(int k = 0; k < power; k++)
							norm_ip *= norm_i;
						M_inv = 1/(1+1/norm_ip);
						norm_i = norm_ip * norm_i * norm_i;
					}
				}
				
				//I compute the scalar product
				/*scal_product = 0;
				for(int i = 0; i < nvel; i++)
				{
					scal_product -= (out_field_trafo_x[i] - sol_x_cont_defl[curr_j][i]) * (out_field_trafo_x[i] - init_snapshot_x[i]);
					scal_product -= (out_field_trafo_y[i] - sol_y_cont_defl[curr_j][i]) * (out_field_trafo_y[i] - init_snapshot_y[i]);
				}  */
				
				for(int i = 0; i < nvel; i++)
				{
					m_fields_t[0]->UpdatePhys()[i] = (out_field_trafo_x[i] - sol_x_cont_defl[curr_j][i]) * (out_field_trafo_x[i] - init_snapshot_x[i]);
					m_fields_t[1]->UpdatePhys()[i] = (out_field_trafo_y[i] - sol_y_cont_defl[curr_j][i]) * (out_field_trafo_y[i] - init_snapshot_y[i]);
				}
				scal_product = -(m_fields_t[0]->Integral(m_fields_t[0]->GetPhys()) + m_fields_t[1]->Integral(m_fields_t[1]->GetPhys()));
				
				scal_product *= power / norm_i;
				//tau *= 1 + (M_inv * scal_product) / (1 - M_inv * scal_product); 
				tau_i *= 1 / (1 - M_inv * scal_product);
				if(tau_i<tau)
					tau = tau_i;
				if(norm_max < norm_i)
					norm_max = norm_i;
					
			}
			// the heuristic
			if(use_heuristic)
			{
				if(tau>0)
				{
					if(last_tau < 0)
					{
						if(last_tau > -10)
							tau = 0.9 * tau + 0.1 * last_tau; // momentum for tau for maintaining small values of tau, if they were too big I don't want to explode
							
						if(tau > 0)
						{
							strength *= 1.75;
						}
						else
						{
							tau *= strength;
						}
						last_tau = tau;
					}
					//else
					//{
						if(tau < 0.6 && tau > 0)
						{
							tau = 0.6;
							last_tau = tau;
						}
						if(tau > 1) // to avoid overshooting
							tau = 1;
						if(danger) //I want to change a lot my solution because I'm in the region of attraction of a previous solution
						{						
							tau = -2*strength;
							last_tau = -9.9999;
							strength *= 1.75;
							cout<<"tau manually set to "<<tau<<endl;
						}
					//}
				}
				else
				{
					if(!far_from_everything && strength*tau>-100)  //I don't want to use the strength factor if I'm far from everything or if tau is already negative enough
						tau = -strength*fabs(tau);
					if(norm_max * tau < -200)
						tau = max(tau / min(norm_max, strength), -100/norm_max);
					if(tau > -0.4)
						tau = -0.4;
					if(tau < -9.9)
					{
						Vmath::Vcopy(out_field_trafo_x.num_elements(), out_field_trafo_x, 1, last_out_field_trafo_x, 1 );
						Vmath::Vcopy(out_field_trafo_y.num_elements(), out_field_trafo_y, 1, last_out_field_trafo_y, 1 );
					}
					last_tau = tau;
				}
			}
			else
			{
				cout<<"Trying to reuse the old solution with tau divided by 2"<<endl;
				use_heuristic = true;
				tau = last_tau / 2;
				last_tau = tau;
			}
				
				cout<<"tau "<<tau<<", scal_product "<<scal_product<<", M_inv "<<M_inv<<", strength "<<strength<<endl;
			//}
			//m_mat[0].m_CoupledBndSys->my_tau_defl = tau;
			cout<<"Viscosity and scaling at iterations number "<<iterations<<": "<<m_kinvis<<", "<<second_param<<"\n"<<endl;  
			
			//I update the solution
			for(int i = 0; i < nvel; i++)
			{
				out_field_trafo_x[i] = tau * out_field_trafo_x[i] + (1 - tau) * init_snapshot_x[i];
				out_field_trafo_y[i] = tau * out_field_trafo_y[i] + (1 - tau) * init_snapshot_y[i];
			}  
       	} 
       	else
       	{
       		if(iterations >= max_iterations/2 && change_method)
       			use_Newton = 0;
       	}   
		
		init_snapshot_x = out_field_trafo_x;
		init_snapshot_y = out_field_trafo_y;
		sol_x_cont_defl[total_solutions_found] = out_field_trafo_x;
		sol_y_cont_defl[total_solutions_found] = out_field_trafo_y;
		
		timer.Stop();
		total_solve_time += timer.TimePerTest(1);
		no_total_solve++;
	}
	
	if(change_method)
		use_Newton = 1;
	
	Array<OneD, Array<OneD, NekDouble> > converged_solution( 2 );
	converged_solution[0] = Array<OneD, NekDouble>(GetNpoints(), 0.0);
	converged_solution[1] = Array<OneD, NekDouble>(GetNpoints(), 0.0);
	if(iterations>=max_iterations)
	{
		converged = false;
		cout<<"DoSolve_at_param didn't converge"<<endl;
		return converged_solution;
	}
	converged = true;
	
	if(total_solutions_found > 2)
	{
		cout<<"arclength_step from "<<arclength_step<<" to "<<max(0.2 * arclength_step, min( min(1.2 * arclength_step, max_step), (arclength_step * 6)/((double)iterations) ))<<endl;
		arclength_step = max(0.2 * arclength_step, min( min(1.2 * arclength_step, max_step), (arclength_step * 6)/((double)iterations) ));
		//cout<<"step_multiplier = "<<max(0.2, min(1.2, 6/((double)iterations) ))<<endl;
		step_multiplier = max(0.2, min(1.2, 6/((double)iterations) ));
	}
	
	converged_solution[0] = init_snapshot_x;
	converged_solution[1] = init_snapshot_y;
	
	if( write_SEM_field )
	{
		std::vector<Array<OneD, NekDouble> > fieldcoeffs(m_fields.num_elements()+1);
	    std::vector<std::string> variables(m_fields.num_elements()+1);
	    int i;
	        
	    for(i = 0; i < m_fields.num_elements(); ++i)
	    {
	        fieldcoeffs[i] = m_fields_t[i]->UpdateCoeffs();
	        variables[i]   = m_boundaryConditions->GetVariable(i);
	    }
	    
	        
	    fieldcoeffs[i] = Array<OneD, NekDouble>(m_fields[0]->GetNcoeffs()); 
	        // project pressure field to velocity space   
	        if(m_singleMode==true)
	        {
	            Array<OneD, NekDouble > tmpfieldcoeffs (m_fields[0]->GetNcoeffs()/2);
	            m_pressure->GetPlane(0)->BwdTrans_IterPerExp(m_pressure->GetPlane(0)->GetCoeffs(), m_pressure->GetPlane(0)->UpdatePhys());
	            m_pressure->GetPlane(1)->BwdTrans_IterPerExp(m_pressure->GetPlane(1)->GetCoeffs(), m_pressure->GetPlane(1)->UpdatePhys()); 
	            m_fields[0]->GetPlane(0)->FwdTrans_IterPerExp(m_pressure->GetPlane(0)->GetPhys(),fieldcoeffs[i]);
	            m_fields[0]->GetPlane(1)->FwdTrans_IterPerExp(m_pressure->GetPlane(1)->GetPhys(),tmpfieldcoeffs);
	            for(int e=0; e<m_fields[0]->GetNcoeffs()/2; e++)
	            {
	                fieldcoeffs[i][e+m_fields[0]->GetNcoeffs()/2] = tmpfieldcoeffs[e];
	            }          
	        }
	        else
	        {
	        	//2D simulations
	            m_pressure->BwdTrans_IterPerExp(m_pressure->GetCoeffs(),m_pressure->UpdatePhys());
	            m_fields[0]->FwdTrans_IterPerExp(m_pressure->GetPhys(),fieldcoeffs[i]);
	        }
	        variables[i] = "p";   
	    
	    std::stringstream sstm;
		//sstm << "Offline_"<<second_param<<"_"<<(total_solutions_found + 1)<<".fld";
		sstm << "Offline_"<<(total_solutions_found + 1)<<".fld";
		std::string outname = sstm.str();
	        
	    WriteFld(outname,m_fields_t[0],fieldcoeffs,variables); 
	}

	return converged_solution;
    }

    Eigen::MatrixXd CoupledLinearNS_trafoP::DoTrafo(Array<OneD, Array<OneD, NekDouble> > snapshot_x_collection, Array<OneD, Array<OneD, NekDouble> > snapshot_y_collection, Array<OneD, NekDouble> param_vector)
    {
	int Nmax = param_vector.num_elements();
	//DoInitialise();
	DoInitialiseAdv(snapshot_x_collection[0], snapshot_y_collection[0]); // replaces .DoInitialise();

	DoSolve();

	Eigen::MatrixXd collect_f_bnd( curr_f_bnd.size() , Nmax );
	Eigen::MatrixXd collect_f_p( curr_f_p.size() , Nmax );
	Eigen::MatrixXd collect_f_int( curr_f_int.size() , Nmax );
	for (int i=0; i<Nmax; i++)
	{
		Set_m_kinvis( param_vector[i] );
		second_param = param_vector2[i];
			
		//cout<<"\nparam_vector["<<i<<"] = "<<param_vector[i]<<endl;
		cout<<"\nparams: "<<param_vector[i]<<" "<<param_vector2[i]<<endl;	
	//	CLNS_trafo.DoInitialise();
		DoInitialiseAdv(snapshot_x_collection[i], snapshot_y_collection[i]); // replaces .DoInitialise();
		DoSolve();

		// compare the accuracy
		Array<OneD, MultiRegions::ExpListSharedPtr> m_fields_t = UpdateFields();
		m_fields_t[0]->BwdTrans(m_fields_t[0]->GetCoeffs(), m_fields_t[0]->UpdatePhys());
		m_fields_t[1]->BwdTrans(m_fields_t[1]->GetCoeffs(), m_fields_t[1]->UpdatePhys());
		Array<OneD, NekDouble> out_field_trafo_x(GetNpoints(), 0.0);
		Array<OneD, NekDouble> out_field_trafo_y(GetNpoints(), 0.0);

		Eigen::VectorXd csx0_trafo(GetNpoints());
		Eigen::VectorXd csy0_trafo(GetNpoints());
		Eigen::VectorXd csx0(GetNpoints());
		Eigen::VectorXd csy0(GetNpoints());

		CopyFromPhysField(0, out_field_trafo_x); 
		CopyFromPhysField(1, out_field_trafo_y);
		for( int index_conv = 0; index_conv < GetNpoints(); ++index_conv)
		{
			csx0_trafo(index_conv) = out_field_trafo_x[index_conv];
			csy0_trafo(index_conv) = out_field_trafo_y[index_conv];
			csx0(index_conv) = snapshot_x_collection[i][index_conv];
			csy0(index_conv) = snapshot_y_collection[i][index_conv];
		}

		//if (debug_mode)
		{
			cout << "csx0.norm() " << csx0.norm() << endl;
			cout << "csx0_trafo.norm() " << csx0_trafo.norm() << endl;
			cout << "csy0.norm() " << csy0.norm() << endl;
			cout << "csy0_trafo.norm() " << csy0_trafo.norm() << endl;
		}
		
		Eigen::VectorXd trafo_f_bnd = curr_f_bnd;
		Eigen::VectorXd trafo_f_p = curr_f_p;
		Eigen::VectorXd trafo_f_int = curr_f_int;

		collect_f_bnd.col(i) = trafo_f_bnd;
		collect_f_p.col(i) = trafo_f_p;
		collect_f_int.col(i) = trafo_f_int;
	}
	Eigen::MatrixXd collect_f_all( curr_f_bnd.size()+curr_f_p.size()+curr_f_int.size() , Nmax );
	collect_f_all.block(0,0,collect_f_bnd.rows(),collect_f_bnd.cols()) = collect_f_bnd;
	collect_f_all.block(collect_f_bnd.rows(),0,collect_f_p.rows(),collect_f_p.cols()) = collect_f_p;
	collect_f_all.block(collect_f_bnd.rows()+collect_f_p.rows(),0,collect_f_int.rows(),collect_f_int.cols()) = collect_f_int;

	return collect_f_all;
    }
    
    void CoupledLinearNS_trafoP::v_DoSolve(void)
    {
        switch(m_equationType)
        {
            case eUnsteadyStokes:
            case eUnsteadyNavierStokes:
                //AdvanceInTime(m_steps);
                UnsteadySystem::v_DoSolve();
                break;
            case eSteadyStokes:
            case eSteadyOseen:
            case eSteadyLinearisedNS:
            {
                Solve();				
                break;
            }
            case eSteadyNavierStokes:
            {	
            
            	cout<<"In DoSolve --> SteadyNavierStokes in file CoupledLinearNS_trafoP.cpp\n";
                Timer Generaltimer;
                Generaltimer.Start();
               
                
                int Check(0);
                
                //Saving the init datas
                Checkpoint_Output(Check);
                Check++;
                
                cout<<"We execute INITIALLY SolveSteadyNavierStokes for m_kinvis = "<<m_kinvis<<" (<=> Re = "<<1/m_kinvis<<")"<<endl;
                cout<<"Initial m_kinvis="<<m_kinvis<<" --- m_kinvisMin="<<m_kinvisMin<<endl;
                
                SolveSteadyNavierStokes();
                
                
                while(m_kinvis > m_kinvisMin)
                {		
                    if (Check == 1)
                    {
                        cout<<"We execute SolveSteadyNavierStokes for m_kinvis = "<<m_kinvis<<" (<=> Re = "<<1/m_kinvis<<")"<<endl;
                        SolveSteadyNavierStokes();
                        Checkpoint_Output(Check);
                        Check++;
                    }
                    
                    Continuation();
                    
                    cout<<"m_kinvis="<<m_kinvis<<" --- m_kinvisMin="<<m_kinvisMin<<endl;
                    
                    if (m_kinvis > m_kinvisMin)
                    {
                        cout<<"We execute SolveSteadyNavierStokes for m_kinvis = "<<m_kinvis<<" (<=> Re = "<<1/m_kinvis<<")"<<endl;
                        SolveSteadyNavierStokes();
                        Checkpoint_Output(Check);
                        Check++;
                    }
                }
                
                
                Generaltimer.Stop();
                cout<<"\nThe total calculation time is : " << Generaltimer.TimePerTest(1)/60 << " minute(s). \n\n";
                
                break;
            }
            case eNoEquationType:
            default:
                ASSERTL0(false,"Unknown or undefined equation type for CoupledLinearNS_trafoP");
        }
    }
    
    
    /** Virtual function to define if operator in DoSolve is negated
     * with regard to the strong form. This is currently only used in
     * Arnoldi solves. For Coupledd solver this is true since Stokes
     * operator is set up as a LHS rather than RHS operation
     */
    bool CoupledLinearNS_trafoP::v_NegatedOp(void)
    {
        return true; 
    }
    
    void CoupledLinearNS_trafoP::Solve(void)
    {
        const unsigned int ncmpt = m_velocity.num_elements();
        Array<OneD, Array<OneD, NekDouble> > forcing_phys(ncmpt);
        Array<OneD, Array<OneD, NekDouble> > forcing     (ncmpt);

        for(int i = 0; i < ncmpt; ++i)
        {
            forcing_phys[i] = Array<OneD, NekDouble> (m_fields[m_velocity[0]]->GetNpoints(), 0.0);
            forcing[i]      = Array<OneD, NekDouble> (m_fields[m_velocity[0]]->GetNcoeffs(),0.0);
        }

        std::vector<SolverUtils::ForcingSharedPtr>::const_iterator x;
        for (x = m_forcing.begin(); x != m_forcing.end(); ++x)
        {
            const NekDouble time = 0;
            (*x)->Apply(m_fields, forcing_phys, forcing_phys, time);
        }

                 Array<OneD, Array<OneD, NekDouble> > AdvField(m_velocity.num_elements());
		Array<OneD, Array<OneD, NekDouble> > Eval_Adv(m_velocity.num_elements());
		Array<OneD, Array<OneD, NekDouble> > AdvTerm(m_velocity.num_elements());
                 for(int il = 0; il < m_velocity.num_elements(); ++il)
                 {
                     AdvField[il] = Array<OneD, NekDouble> (m_fields[m_velocity[il]]->GetTotPoints(),0.0);
			Eval_Adv[il] = Array<OneD, NekDouble> (m_fields[m_velocity[il]]->GetTotPoints(),0.0);
			AdvTerm[il] = Array<OneD, NekDouble> (m_fields[m_velocity[il]]->GetNcoeffs(),0.0);
                 }
                 
                 ASSERTL0(m_session->DefinesFunction("AdvectionVelocity"),
                          "Advection Velocity section must be defined in "
                          "session file.");
                 
                 std::vector<std::string> fieldStr;
                 for(int il = 0; il < m_velocity.num_elements(); ++il)
                 {
                     fieldStr.push_back(m_boundaryConditions->GetVariable(m_velocity[il]));
                 }
                 EvaluateFunction(fieldStr,AdvField,"AdvectionVelocity");

//		EvaluateAdvectionTerms(AdvField, Eval_Adv);
		// here myAdvField
		EvaluateAdvectionTerms(myAdvField, Eval_Adv);
	// actually have the right Adv velo



        for (unsigned int i = 0; i < ncmpt; ++i)
        {
            bool waveSpace = m_fields[m_velocity[i]]->GetWaveSpace();
            m_fields[i]->SetWaveSpace(true);
            m_fields[i]->IProductWRTBase(forcing_phys[i], forcing[i]);
            m_fields[m_velocity[i]]->IProductWRTBase(Eval_Adv[i], AdvTerm[i]); //(w, (u.grad)u)
	    if (use_Newton)
	    {
		for (unsigned int il = 0; il < forcing[i].num_elements(); ++il)
	        {
			forcing[i][il] = forcing[i][il] - AdvTerm[i][il];
//			cout << Eval_Adv[i][il] << endl;
		}
	    }
            m_fields[i]->SetWaveSpace(waveSpace);
        }

        SolveLinearNS(forcing);
    }
    
    void CoupledLinearNS_trafoP::DefineForcingTerm(void)
    {
        m_ForcingTerm = Array<OneD, Array<OneD, NekDouble> > (m_velocity.num_elements());
        m_ForcingTerm_Coeffs = Array<OneD, Array<OneD, NekDouble> > (m_velocity.num_elements());
        
        for(int i = 0; i < m_velocity.num_elements(); ++i)
        {
            m_ForcingTerm[i] = Array<OneD, NekDouble> (m_fields[m_velocity[i]]->GetTotPoints(),0.0);
            m_ForcingTerm_Coeffs[i] = Array<OneD, NekDouble> (m_fields[m_velocity[i]]->GetNcoeffs(),0.0);
        }
        
        if(m_session->DefinesFunction("ForcingTerm"))
        {
            std::vector<std::string> fieldStr;
            for(int i = 0; i < m_velocity.num_elements(); ++i)
            {
                fieldStr.push_back(m_boundaryConditions->GetVariable(m_velocity[i]));
            }
            EvaluateFunction(fieldStr, m_ForcingTerm, "ForcingTerm");
            for(int i = 0; i < m_velocity.num_elements(); ++i)
            {
                m_fields[m_velocity[i]]->FwdTrans_IterPerExp(m_ForcingTerm[i], m_ForcingTerm_Coeffs[i]);
            }
        }
        else
        {
            cout << "'ForcingTerm' section has not been defined in the input file => forcing=0" << endl;
        }
    }
    
    void CoupledLinearNS_trafoP::SolveSteadyNavierStokes(void)
    {
        Timer Newtontimer;
        Newtontimer.Start();
        
        int m_MatrixSetUpStep;
        m_session->LoadParameter("MatrixSetUpStep", m_MatrixSetUpStep);
        
        Array<OneD, Array<OneD, NekDouble> > RHS_Coeffs(m_velocity.num_elements());
        Array<OneD, Array<OneD, NekDouble> > RHS_Phys(m_velocity.num_elements());
        Array<OneD, Array<OneD, NekDouble> > delta_velocity_Phys(m_velocity.num_elements());
        Array<OneD, Array<OneD, NekDouble> >Velocity_Phys(m_velocity.num_elements());
        Array<OneD, NekDouble > L2_norm(m_velocity.num_elements(), 1.0);
        Array<OneD, NekDouble > Inf_norm(m_velocity.num_elements(), 1.0);
        
        for(int i = 0; i < m_velocity.num_elements(); ++i)
        {				
            delta_velocity_Phys[i] = Array<OneD, NekDouble> (m_fields[m_velocity[i]]->GetTotPoints(),1.0); 
            Velocity_Phys[i] = Array<OneD, NekDouble> (m_fields[m_velocity[i]]->GetTotPoints(),0.0);
        }
        
        m_counter=1;
        
        L2Norm(delta_velocity_Phys, L2_norm);
        //while(max(Inf_norm[0], Inf_norm[1]) > m_tol)
        while(max(L2_norm[0], L2_norm[1]) > m_tol)
        {
            if(m_counter == 1) 
                //At the first Newton step, we use the solution of the
                //Stokes problem (if Restart=0 in input file) Or the
                //solution of the .rst file (if Restart=1 in input
                //file)
            {			
                for(int i = 0; i < m_velocity.num_elements(); ++i)
                {
                    RHS_Coeffs[i] = Array<OneD, NekDouble> (m_fields[m_velocity[i]]->GetNcoeffs(),0.0);
                    RHS_Phys[i] = Array<OneD, NekDouble> (m_fields[m_velocity[i]]->GetTotPoints(),0.0);
                }
                for(int i = 0; i < m_velocity.num_elements(); ++i)
                {
                    m_fields[m_velocity[i]]->BwdTrans_IterPerExp(m_fields[m_velocity[i]]->GetCoeffs(), Velocity_Phys[i]);
                }
                
                m_initialStep = true; 
                EvaluateNewtonRHS(Velocity_Phys, RHS_Coeffs);
                SetUpCoupledMatrix(0.0, Velocity_Phys, true);
                SolveLinearNS(RHS_Coeffs);
                m_initialStep = false; 
            }
            if(m_counter > 1)
            {
                EvaluateNewtonRHS(Velocity_Phys, RHS_Coeffs);
                if(m_counter%m_MatrixSetUpStep == 0) //Setting Up the matrix is expensive. We do it at each "m_MatrixSetUpStep" step.
                {
                    SetUpCoupledMatrix(0.0, Velocity_Phys, true);
                }
                SolveLinearNS(RHS_Coeffs);
            }
            
            for(int i = 0; i < m_velocity.num_elements(); ++i)
            {
                m_fields[m_velocity[i]]->BwdTrans_IterPerExp(RHS_Coeffs[i], RHS_Phys[i]);
                m_fields[m_velocity[i]]->BwdTrans_IterPerExp(m_fields[m_velocity[i]]->GetCoeffs(), delta_velocity_Phys[i]); 
            }
            
            for(int i = 0; i < m_velocity.num_elements(); ++i)
            {
                Vmath::Vadd(Velocity_Phys[i].num_elements(),Velocity_Phys[i], 1, delta_velocity_Phys[i], 1, Velocity_Phys[i], 1);
            }	
            //InfNorm(delta_velocity_Phys, Inf_norm);
            L2Norm(delta_velocity_Phys, L2_norm);
            
            if(max(Inf_norm[0], Inf_norm[1]) > 100)
            {
                cout<<"\nThe Newton method has failed at m_kinvis = "<<m_kinvis<<" (<=> Re = " << 1/m_kinvis << ")"<< endl;
                ASSERTL0(0, "The Newton method has failed... \n");
            }
            
            
            cout << "\n";
            m_counter++;
        }	
        
        if (m_counter > 1) //We save u:=u+\delta u in u->Coeffs
        {
            for(int i = 0; i < m_velocity.num_elements(); ++i)
            {			
                m_fields[m_velocity[i]]->FwdTrans(Velocity_Phys[i], m_fields[m_velocity[i]]->UpdateCoeffs());
            }
        }
        
        Newtontimer.Stop();
        cout<<"We have done "<< m_counter-1 << " iteration(s) in " << Newtontimer.TimePerTest(1)/60 << " minute(s). \n\n";
    }
    
    double CoupledLinearNS_trafoP::ComputeContinuationGuess(int curr_i, int prev_i)
    {
		// bordering algorithm present in Keller's book (with same notation) 
    	
    	Array<OneD, Array<OneD, NekDouble> > u_N(m_velocity.num_elements());
        Array<OneD, Array<OneD, NekDouble> > tmp_RHS(m_velocity.num_elements());
        Array<OneD, Array<OneD, NekDouble> > RHS(m_velocity.num_elements());
        Array<OneD, Array<OneD, NekDouble> > y(m_velocity.num_elements());
        Array<OneD, Array<OneD, NekDouble> > z(m_velocity.num_elements());
        Array<OneD, Array<OneD, NekDouble> > guess(m_velocity.num_elements());
        
        sol_x_cont_defl[total_solutions_found] = Array<OneD, NekDouble>(sol_x_cont_defl[0].num_elements(),0.0);	
        sol_y_cont_defl[total_solutions_found] = Array<OneD, NekDouble>(sol_y_cont_defl[0].num_elements(),0.0);	
        
        Array<OneD, NekDouble> cx(sol_x_cont_defl[curr_i].num_elements()); // I build the vector c using a secant method
        Array<OneD, NekDouble> cy(sol_y_cont_defl[curr_i].num_elements());
        for(int i = 0; i < cx.num_elements(); i++)
        	cx[i] = (sol_x_cont_defl[curr_i][i] - sol_x_cont_defl[prev_i][i])/(arclength_step);
        for(int i = 0; i < cy.num_elements(); i++)
        	cy[i] = (sol_y_cont_defl[curr_i][i] - sol_y_cont_defl[prev_i][i])/(arclength_step);
        
        guess[0] = Array<OneD, NekDouble> (m_fields[m_velocity[0]]->GetTotPoints(),0.0);
        guess[1] = Array<OneD, NekDouble> (m_fields[m_velocity[1]]->GetTotPoints(),0.0);
        
        guess[0] = sol_x_cont_defl[curr_i];
        guess[1] = sol_y_cont_defl[curr_i];
        
        DoInitialiseAdv(guess[0], guess[1]);
        DoSolve();
        for(int i = 0; i < m_velocity.num_elements(); ++i)
        {
            z[i] = Array<OneD, NekDouble> (m_fields[m_velocity[i]]->GetTotPoints(),0.0);	
            m_fields[m_velocity[i]]->BwdTrans_IterPerExp(m_fields[m_velocity[i]]->GetCoeffs(), z[i]);
        } 	
        
        for(int i = 0; i < m_velocity.num_elements(); ++i)
        {
            //u_N[i] = Array<OneD, NekDouble> (m_fields[m_velocity[i]]->GetTotPoints(),0.0);	
            //m_fields[m_velocity[i]]->BwdTrans_IterPerExp(m_fields[m_velocity[i]]->GetCoeffs(), u_N[i]);
            
            u_N[i] = guess[i];
            
            RHS[i] = Array<OneD, NekDouble> (m_fields[m_velocity[i]]->GetTotPoints(),0.0);	
            tmp_RHS[i] = Array<OneD, NekDouble> (m_fields[m_velocity[i]]->GetTotPoints(),0.0);	
            
            m_fields[m_velocity[i]]->PhysDeriv(i, u_N[i], tmp_RHS[i]);
            Vmath::Smul(tmp_RHS[i].num_elements(), m_kinvis, tmp_RHS[i], 1, tmp_RHS[i], 1);
            //Vmath::Smul(tmp_RHS[i].num_elements(), param_vector[curr_i], tmp_RHS[i], 1, tmp_RHS[i], 1);
            
            bool waveSpace = m_fields[m_velocity[i]]->GetWaveSpace();
            m_fields[m_velocity[i]]->SetWaveSpace(true);
            m_fields[m_velocity[i]]->IProductWRTDerivBase(i, tmp_RHS[i], RHS[i]);
            m_fields[m_velocity[i]]->SetWaveSpace(waveSpace);
        }
        
        SetUpCoupledMatrix(0.0, u_N, true);
        SolveLinearNS(RHS);
        
        for(int i = 0; i < m_velocity.num_elements(); ++i)
        {
            y[i] = Array<OneD, NekDouble> (m_fields[m_velocity[i]]->GetTotPoints(),0.0);	
            m_fields[m_velocity[i]]->BwdTrans_IterPerExp(m_fields[m_velocity[i]]->GetCoeffs(), y[i]);
            
            Vmath::Smul(y[i].num_elements(), m_kinvis, y[i], 1, y[i], 1);
            //Vmath::Smul(y[i].num_elements(), param_vector[curr_i], y[i], 1, y[i], 1);
            Vmath::Vadd(y[i].num_elements(), y[i], 1, u_N[i], 1, y[i], 1);
            
            //m_fields[m_velocity[i]]->FwdTrans(u_star[i], m_fields[m_velocity[i]]->UpdateCoeffs());
            //m_fields[m_velocity[i]]->BwdTrans(m_fields[m_velocity[i]]->GetCoeffs(), m_fields[m_velocity[i]]->UpdatePhys());
        }
        for(int i = 0; i < guess.num_elements(); i++)
        {
        	guess[i] = y[i];
        }
        
        double c_dot_z, c_dot_y, csi;
        c_dot_z = Vmath::Dot(cx.num_elements(), cx, z[0]);
        c_dot_z += Vmath::Dot(cy.num_elements(), cy, z[1]);
        
        c_dot_y = Vmath::Dot(cx.num_elements(), cx, y[0]);
        c_dot_y += Vmath::Dot(cy.num_elements(), cy, y[1]);
        
        csi = (arclength_step - c_dot_z) / ((param_vector[curr_i] - param_vector[prev_i])/arclength_step - c_dot_y);
        for(int i = 0; i < guess.num_elements(); i++)
        {
        	Vmath::Smul(y[i].num_elements(), csi, y[i], 1, y[i], 1);
        	Vmath::Vsub(y[i].num_elements(), z[i], 1, u_N[i], 1, z[i], 1);
    	}
       
		
        for(int i = 0; i < sol_x_cont_defl[total_solutions_found].num_elements(); i++)
        {
        	sol_x_cont_defl[total_solutions_found][i] = sol_x_cont_defl[curr_i][i] + z[0][i];
        	sol_y_cont_defl[total_solutions_found][i] = sol_y_cont_defl[curr_i][i] + z[1][i];
        }  
        m_kinvis -= csi;
        //m_kinvis = param_vector[curr_i] - csi;
        
        m_fields[0]->FwdTrans(sol_x_cont_defl[total_solutions_found], m_fields[0]->UpdateCoeffs());
        m_fields[1]->FwdTrans(sol_y_cont_defl[total_solutions_found], m_fields[1]->UpdateCoeffs());
        
        m_fields[0]->BwdTrans(m_fields[0]->GetCoeffs(), m_fields[0]->UpdatePhys());
        m_fields[1]->BwdTrans(m_fields[1]->GetCoeffs(), m_fields[1]->UpdatePhys());
        
        //m_kinvis -= m_kinvis*m_KinvisPercentage/100;
        cout<<"end of computeguess with m_kinvis = "<<m_kinvis<<endl;
        return csi;
    }		
    
    void CoupledLinearNS_trafoP::Continuation(void)
    {
        Array<OneD, Array<OneD, NekDouble> > u_N(m_velocity.num_elements());
        Array<OneD, Array<OneD, NekDouble> > tmp_RHS(m_velocity.num_elements());
        Array<OneD, Array<OneD, NekDouble> > RHS(m_velocity.num_elements());
        Array<OneD, Array<OneD, NekDouble> > u_star(m_velocity.num_elements());
        
        cout << "We apply the continuation method: " <<endl;
        
        for(int i = 0; i < m_velocity.num_elements(); ++i)
        {
            u_N[i] = Array<OneD, NekDouble> (m_fields[m_velocity[i]]->GetTotPoints(),0.0);	
            m_fields[m_velocity[i]]->BwdTrans_IterPerExp(m_fields[m_velocity[i]]->GetCoeffs(), u_N[i]);
            
            RHS[i] = Array<OneD, NekDouble> (m_fields[m_velocity[i]]->GetTotPoints(),0.0);	
            tmp_RHS[i] = Array<OneD, NekDouble> (m_fields[m_velocity[i]]->GetTotPoints(),0.0);	
            
            m_fields[m_velocity[i]]->PhysDeriv(i, u_N[i], tmp_RHS[i]);
            Vmath::Smul(tmp_RHS[i].num_elements(), m_kinvis, tmp_RHS[i], 1, tmp_RHS[i], 1);
            
            bool waveSpace = m_fields[m_velocity[i]]->GetWaveSpace();
            m_fields[m_velocity[i]]->SetWaveSpace(true);
            m_fields[m_velocity[i]]->IProductWRTDerivBase(i, tmp_RHS[i], RHS[i]);
            m_fields[m_velocity[i]]->SetWaveSpace(waveSpace);
        }
        
        SetUpCoupledMatrix(0.0, u_N, true);
        SolveLinearNS(RHS);
        
        for(int i = 0; i < m_velocity.num_elements(); ++i)
        {
            u_star[i] = Array<OneD, NekDouble> (m_fields[m_velocity[i]]->GetTotPoints(),0.0);	
            m_fields[m_velocity[i]]->BwdTrans_IterPerExp(m_fields[m_velocity[i]]->GetCoeffs(), u_star[i]);
            
            //u_star(k+1) = u_N(k) + DeltaKinvis *  u_star(k)
            Vmath::Smul(u_star[i].num_elements(), m_kinvis, u_star[i], 1, u_star[i], 1);
            Vmath::Vadd(u_star[i].num_elements(), u_star[i], 1, u_N[i], 1, u_star[i], 1);
            
            m_fields[m_velocity[i]]->FwdTrans(u_star[i], m_fields[m_velocity[i]]->UpdateCoeffs());
        }
        
        m_kinvis -= m_kinvis*m_KinvisPercentage/100;
    }		
    
    
    void  CoupledLinearNS_trafoP::InfNorm(Array<OneD, Array<OneD, NekDouble> > &inarray,
                                   Array<OneD, NekDouble> &outarray)
    {
        for(int i = 0; i < m_velocity.num_elements(); ++i)
        {
            outarray[i] = 0.0;
            for(int j = 0; j < inarray[i].num_elements(); ++j)
            {
                if(inarray[i][j] > outarray[i]) 
                {
                    outarray[i] = inarray[i][j];
                }
            }
            cout << "InfNorm["<<i<<"] = "<< outarray[i] <<endl;
        }
    }
    
    void  CoupledLinearNS_trafoP::L2Norm(Array<OneD, Array<OneD, NekDouble> > &inarray,
                                  Array<OneD, NekDouble> &outarray)
    {
        for(int i = 0; i < m_velocity.num_elements(); ++i)
        {
            outarray[i] = 0.0;
            for(int j = 0; j < inarray[i].num_elements(); ++j)
            {
                outarray[i] += inarray[i][j]*inarray[i][j];
            }
            outarray[i]=sqrt(outarray[i]);
            cout << "L2Norm["<<i<<"] = "<< outarray[i] <<endl;
        }
    }
    
    
    void CoupledLinearNS_trafoP::EvaluateNewtonRHS(Array<OneD, Array<OneD, NekDouble> > &Velocity,
                                            Array<OneD, Array<OneD, NekDouble> > &outarray)
    {
        Array<OneD, Array<OneD, NekDouble> > Eval_Adv(m_velocity.num_elements());
        Array<OneD, Array<OneD, NekDouble> > tmp_DerVel(m_velocity.num_elements());
        Array<OneD, Array<OneD, NekDouble> > AdvTerm(m_velocity.num_elements());
        Array<OneD, Array<OneD, NekDouble> > ViscTerm(m_velocity.num_elements());
        Array<OneD, Array<OneD, NekDouble> > Forc(m_velocity.num_elements());
        for(int i = 0; i < m_velocity.num_elements(); ++i)
        {
            Eval_Adv[i] = Array<OneD, NekDouble> (m_fields[m_velocity[i]]->GetTotPoints(),0.0);
            tmp_DerVel[i] = Array<OneD, NekDouble> (m_fields[m_velocity[i]]->GetTotPoints(),0.0);
            
            AdvTerm[i] = Array<OneD, NekDouble> (m_fields[m_velocity[i]]->GetTotPoints(),0.0);
            ViscTerm[i] = Array<OneD, NekDouble> (m_fields[m_velocity[i]]->GetTotPoints(),0.0);
            Forc[i] = Array<OneD, NekDouble> (m_fields[m_velocity[i]]->GetTotPoints(),0.0);
            outarray[i] = Array<OneD, NekDouble> (m_fields[m_velocity[i]]->GetTotPoints(),0.0);
            
            m_fields[m_velocity[i]]->PhysDeriv(i, Velocity[i], tmp_DerVel[i]);
            
            Vmath::Smul(tmp_DerVel[i].num_elements(), m_kinvis, tmp_DerVel[i], 1, tmp_DerVel[i], 1);
        }
        EvaluateAdvectionTerms(Velocity, Eval_Adv);
        
        for(int i = 0; i < m_velocity.num_elements(); ++i)
        {
            bool waveSpace = m_fields[m_velocity[i]]->GetWaveSpace();
            m_fields[m_velocity[i]]->SetWaveSpace(true);
            m_fields[m_velocity[i]]->IProductWRTBase(Eval_Adv[i], AdvTerm[i]); //(w, (u.grad)u)
            	m_fields[m_velocity[i]]->IProductWRTDerivBase(i, tmp_DerVel[i], ViscTerm[i]); //(grad w, grad u)
          
            if(m_session->DefinesFunction("ForcingTerm"))
            	m_fields[m_velocity[i]]->IProductWRTBase(m_ForcingTerm[i], Forc[i]); //(w, f)
           
            m_fields[m_velocity[i]]->SetWaveSpace(waveSpace);
            Vmath::Vsub(outarray[i].num_elements(), outarray[i], 1, AdvTerm[i], 1, outarray[i], 1);
            Vmath::Vsub(outarray[i].num_elements(), outarray[i], 1, ViscTerm[i], 1, outarray[i], 1);
            
            Vmath::Vadd(outarray[i].num_elements(), outarray[i], 1, Forc[i], 1, outarray[i], 1);
        }
    }
    
    
    
    const SpatialDomains::ExpansionMap &CoupledLinearNS_trafoP::GenPressureExp(const SpatialDomains::ExpansionMap &VelExp)
    {
        int i;
        SpatialDomains::ExpansionMapShPtr returnval;
        
        returnval = MemoryManager<SpatialDomains::ExpansionMap>::AllocateSharedPtr();
        
        SpatialDomains::ExpansionMap::const_iterator  expMapIter;
        int nummodes;
        
        for (expMapIter = VelExp.begin(); expMapIter != VelExp.end(); ++expMapIter)
        {
            LibUtilities::BasisKeyVector BasisVec;
            
            for(i = 0; i <  expMapIter->second->m_basisKeyVector.size(); ++i)
            {
                LibUtilities::BasisKey B = expMapIter->second->m_basisKeyVector[i];
                nummodes = B.GetNumModes();
                ASSERTL0(nummodes > 3,"Velocity polynomial space not sufficiently high (>= 4)");
                // Should probably set to be an orthogonal basis. 
                LibUtilities::BasisKey newB(B.GetBasisType(),nummodes-2,B.GetPointsKey());
                BasisVec.push_back(newB);
            }
            
            // Put new expansion into list. 
            SpatialDomains::ExpansionShPtr expansionElementShPtr =
            MemoryManager<SpatialDomains::Expansion>::AllocateSharedPtr(expMapIter->second->m_geomShPtr, BasisVec);
            (*returnval)[expMapIter->first] = expansionElementShPtr;
        }
        
        // Save expansion into graph. 
        m_graph->SetExpansions("p",returnval);
        
        return *returnval;
    }
    
    /** 
     *  @param forcing A list of forcing functions for each velocity
     *  component
     *   
     *  The routine involves two levels of static
     *  condensations. Initially we require a statically condensed
     *  forcing function which requires the following manipulation
     *
     * \f[ {F\_bnd} = {\bf f}_{bnd} -m\_B \,m\_Cinv\, {\bf f}_{int},
     * \hspace{1cm} F\_p = m\_D\_{int}\, m\_Cinv\, {\bf f}_{int} \f]
     * 
     *  Where \f${\bf f}_{bnd}\f$ denote the forcing degrees of
     *  freedom of the elemental velocities on the boundary of the
     *  element, \f${\bf f}_{int}\f$ denote the forcing degrees of
     *  freedom of the elemental velocities on the interior of the
     *  element. (see detailed description for more details).  
     * 
     * This vector is further manipulated into 
     *
     * \f[ Fh\_{bnd} = \left [ \begin{array}{c} f\_{bnd} -m\_B \,
     * m\_Cinv\, {\bf f}_{int}\\ \left [m\_D\_{int} \, m\_Cinv \,{\bf
     * f}_{int} \right]_0 \end{array}\right ] \hspace{1cm} [Fh\_p]_{i} =
     * \begin{array}{c} [m\_D\_{int} \, m\_Cinv \, {\bf
     * f}_{int}]_{i+1} \end{array} \f]
     *
     * where \f$-{[}m\_D\_{int}^T\, m\_Cinv \,{\bf f}_{int}]_0\f$
     * which is corresponds to the mean mode of the pressure degrees
     * of freedom and is now added to the boundary system and the
     * remainder of the block becomes the interior forcing for the
     * inner static condensation (see detailed description for more
     * details) which is set up in a GlobalLinSysDirectStaticCond
     * class.
     * 
     * Finally we perform the final maniplation of the forcing to 
     * using hte 
     * \f[ Fh\_{bnd} = Fh\_{bnd} - m\_Bh \,m\_Chinv \, Fh\_p \f]
     *
     * We can now call the solver to the global coupled boundary
     * system (through the call to #m_CoupledBndSys->Solve) to obtain
     * the velocity boundary solution as the mean pressure solution,
     * i.e.
     * 
     * \f[ {\cal A}^T(\hat{A} - \hat{C}^T \hat{D}^{-1} \hat{B} ){\cal
     * A} \, Bnd =  Fh\_{bnd} \f]
     * 
     * Once we know the solution to the above the rest of the pressure
     * modes are recoverable thorugh
     * 
     *  \f[ Ph = m\_Dhinv\, (Bnd  - m\_Ch^T \, Fh_{bnd}) \f]
     * 
     * We can now unpack \f$ Fh\_{bnd} \f$ (last elemental mode) and
     * \f$ Ph \f$ into #m_pressure and \f$ F_p\f$ and \f$ Fh\_{bnd}\f$
     * into a closed pack list of boundary velocoity degrees of
     * freedom stored in \f$ F\_bnd\f$.
     * 
     * Finally the interior velocity degrees of freedom are then
     * obtained through the relationship
     * 
     *   \f[ F\_{int} = m\_Cinv\ ( F\_{int} + m\_D\_{int}^T\,
     *   F\_p - m\_Btilde^T\, Bnd) \f]
     * 
     * We then unpack the solution back to the MultiRegion structures
     * #m_velocity and #m_pressure
     */
    void CoupledLinearNS_trafoP::SolveLinearNS(const Array<OneD, Array<OneD, NekDouble> > &forcing)
    {
        int i,n;
        Array<OneD,  MultiRegions::ExpListSharedPtr> vel_fields(m_velocity.num_elements());
        Array<OneD, Array<OneD, NekDouble> > force(m_velocity.num_elements());
        if(m_HomogeneousType == eHomogeneous1D)
        {
            int ncoeffsplane = m_fields[m_velocity[0]]->GetPlane(0)->GetNcoeffs();
            for(n = 0; n < m_npointsZ/2; ++n)
            {
                // Get the a Fourier mode of velocity and forcing components. 
                for(i = 0; i < m_velocity.num_elements(); ++i)
                {
                    vel_fields[i] = m_fields[m_velocity[i]]->GetPlane(2*n);
                    // Note this needs to correlate with how we pass forcing
                    force[i] = forcing[i] + 2*n*ncoeffsplane;
                }
                
                SolveLinearNS(force,vel_fields,m_pressure->GetPlane(2*n),n);
            }
            for(i = 0; i < m_velocity.num_elements(); ++i)
            {
                m_fields[m_velocity[i]]->SetPhysState(false);
            }
            m_pressure->SetPhysState(false);
        }
        else
        {
            for(i = 0; i < m_velocity.num_elements(); ++i)
            {
                vel_fields[i] = m_fields[m_velocity[i]];
                // Note this needs to correlate with how we pass forcing
                force[i] = forcing[i];
            }
            SolveLinearNS(force,vel_fields,m_pressure);
        }
    }
    
    void CoupledLinearNS_trafoP::SolveLinearNS(const Array<OneD, Array<OneD, NekDouble> > &forcing,  Array<OneD, MultiRegions::ExpListSharedPtr> &fields, MultiRegions::ExpListSharedPtr &pressure,  const int mode)
    {
        int i,j,k,n,eid,cnt,cnt1;
        int nbnd,nint,offset;
        int nvel = m_velocity.num_elements();
        int nel  = fields[0]->GetNumElmts();
        Array<OneD, unsigned int> bmap, imap; 
        
        Array<OneD, NekDouble > f_bnd(m_mat[mode].m_BCinv->GetRows());
        NekVector< NekDouble  > F_bnd(f_bnd.num_elements(), f_bnd, eWrapper);
        Array<OneD, NekDouble > f_int(m_mat[mode].m_BCinv->GetColumns());
        NekVector< NekDouble  > F_int(f_int.num_elements(),f_int, eWrapper);
        
        int nz_loc;
        int  nplanecoeffs = fields[m_velocity[0]]->GetNcoeffs();// this is fine since we pass the nplane coeff data. 
        
        if(mode) // Homogeneous mode flag
        {
            nz_loc = 2;
        }
        else
        {
            if(m_singleMode)
            {
                nz_loc = 2;
            }
            else
            {
                nz_loc = 1;
                if(m_HomogeneousType == eHomogeneous1D)
                {
                    // Zero fields to set complex mode to zero;
                    for(i = 0; i < fields.num_elements(); ++i)
                    {
                        Vmath::Zero(2*fields[i]->GetNcoeffs(),fields[i]->UpdateCoeffs(),1);
                    }
                    Vmath::Zero(2*pressure->GetNcoeffs(),pressure->UpdateCoeffs(),1);
                }
            }
        }
        
        // Assemble f_bnd and f_int
        cnt = cnt1 = 0;
        for(i = 0; i < nel; ++i) // loop over elements
        {
            eid = i;
            fields[m_velocity[0]]->GetExp(eid)->GetBoundaryMap(bmap);
            fields[m_velocity[0]]->GetExp(eid)->GetInteriorMap(imap);
            nbnd   = bmap.num_elements();
            nint   = imap.num_elements();
            
            
            offset = fields[m_velocity[0]]->GetCoeff_Offset(eid);
            
            for(j = 0; j < nvel; ++j) // loop over velocity fields 
            {
                for(n = 0; n < nz_loc; ++n)
                {
                    for(k = 0; k < nbnd; ++k)
                    {
                        f_bnd[cnt+k] = forcing[j][n*nplanecoeffs + offset+bmap[k]];
                    }
                    for(k = 0; k < nint; ++k)
                    {
                        f_int[cnt1+k] = forcing[j][n*nplanecoeffs + offset+imap[k]];
                    }
                    cnt  += nbnd;
                    cnt1 += nint;
                }
            }
        }      
        
        Array<OneD, NekDouble > f_p(m_mat[mode].m_D_int->GetRows());
        NekVector<  NekDouble > F_p(f_p.num_elements(),f_p,eWrapper);
        NekVector<  NekDouble > F_p_tmp(m_mat[mode].m_Cinv->GetRows());
        
        
        // fbnd does not currently hold the pressure mean
        F_bnd = F_bnd - (*m_mat[mode].m_BCinv)*F_int;
        F_p_tmp = (*m_mat[mode].m_Cinv)*F_int;
        F_p = (*m_mat[mode].m_D_int) * F_p_tmp;
        
        // construct inner forcing 
        Array<OneD, NekDouble > bnd   (m_locToGloMap[mode]->GetNumGlobalCoeffs(),0.0);
        Array<OneD, NekDouble > fh_bnd(m_locToGloMap[mode]->GetNumGlobalCoeffs(),0.0);
        
        const Array<OneD,const int>& loctoglomap
        = m_locToGloMap[mode]->GetLocalToGlobalMap();
        const Array<OneD,const NekDouble>& loctoglosign
        = m_locToGloMap[mode]->GetLocalToGlobalSign();
        
        offset = cnt = 0; 
        for(i = 0; i < nel; ++i)
        {
            eid  = i;
            nbnd = nz_loc*fields[0]->GetExp(eid)->NumBndryCoeffs(); 
            
            for(j = 0; j < nvel; ++j)
            {
                for(k = 0; k < nbnd; ++k)
                {
                    fh_bnd[loctoglomap[offset+j*nbnd+k]] += 
                    loctoglosign[offset+j*nbnd+k]*f_bnd[cnt+k];
                }
                cnt += nbnd;
            }
            
            nint    = pressure->GetExp(eid)->GetNcoeffs();
            offset += nvel*nbnd + nint*nz_loc; 
        }
        
        offset = cnt1 = 0; 
        for(i = 0; i <  nel; ++i)
        {
            eid  = i;
            nbnd = nz_loc*fields[0]->GetExp(eid)->NumBndryCoeffs(); 
            nint = pressure->GetExp(eid)->GetNcoeffs(); 
            
            for(n = 0; n < nz_loc; ++n)
            {
                for(j = 0; j < nint; ++j)
                {
                    fh_bnd[loctoglomap[offset + nvel*nbnd + n*nint+j]] = f_p[cnt1+j];
                }
                cnt1   += nint;
            }
            offset += nvel*nbnd + nz_loc*nint; 
        }
        
        //  Set Weak BC into f_bnd and Dirichlet Dofs in bnd
        const Array<OneD,const int>& bndmap
        = m_locToGloMap[mode]->GetBndCondCoeffsToGlobalCoeffsMap();
        
        // Forcing function with weak boundary conditions and
        // Dirichlet conditions
        int bndcnt=0;
        
        for(k = 0; k < nvel; ++k)
        {
            const Array<OneD, SpatialDomains::BoundaryConditionShPtr> bndConds = fields[k]->GetBndConditions();
            Array<OneD, const MultiRegions::ExpListSharedPtr> bndCondExp;
            if(m_HomogeneousType == eHomogeneous1D) 
            {
                bndCondExp = m_fields[k]->GetPlane(2*mode)->GetBndCondExpansions();
            }
            else
            {
                bndCondExp = m_fields[k]->GetBndCondExpansions();
            }
            
            for(i = 0; i < bndCondExp.num_elements(); ++i)
            {
                const Array<OneD, const NekDouble > bndCondCoeffs = bndCondExp[i]->GetCoeffs();
                cnt = 0;
                for(n = 0; n < nz_loc; ++n)
                {
                    if(bndConds[i]->GetBoundaryConditionType() 
                        == SpatialDomains::eDirichlet)
                    {
                        for(j = 0; j < (bndCondExp[i])->GetNcoeffs(); j++)
                        {
                            if (m_equationType == eSteadyNavierStokes && m_initialStep == false)
                            {
                                //This condition set all the Dirichlet BC at 0 after
                                //the initial step of the Newton method
                                bnd[bndmap[bndcnt++]] = 0;
                            }
                            else
                            {
                                bnd[bndmap[bndcnt++]] = bndCondCoeffs[cnt++] * second_param;
                            }
                        }
                    }
                    else
                    {                    
                        for(j = 0; j < (bndCondExp[i])->GetNcoeffs(); j++)
                        {
                            fh_bnd[bndmap[bndcnt++]]+= bndCondCoeffs[cnt++];
                        }
                    }
                }
            }
        }
        
        m_mat[mode].m_CoupledBndSys->Solve(fh_bnd,bnd,m_locToGloMap[mode]);
        
        // unpack pressure and velocity boundary systems. 
        offset = cnt = 0; 
        int totpcoeffs = pressure->GetNcoeffs();
        Array<OneD, NekDouble> p_coeffs = pressure->UpdateCoeffs();
        for(i = 0; i <  nel; ++i)
        {
            eid  = i;
            nbnd = nz_loc*fields[0]->GetExp(eid)->NumBndryCoeffs(); 
            nint = pressure->GetExp(eid)->GetNcoeffs(); 
            
            for(j = 0; j < nvel; ++j)
            {
                for(k = 0; k < nbnd; ++k)
                {
                    f_bnd[cnt+k] = loctoglosign[offset+j*nbnd+k]*bnd[loctoglomap[offset + j*nbnd + k]];
                }
                cnt += nbnd;
            }
            offset += nvel*nbnd + nint*nz_loc;
        }
        
        pressure->SetPhysState(false);
        
        offset = cnt = cnt1 = 0;
        for(i = 0; i < nel; ++i)
        {
            eid  = i;
            nint = pressure->GetExp(eid)->GetNcoeffs(); 
            nbnd = fields[0]->GetExp(eid)->NumBndryCoeffs(); 
            cnt1 = pressure->GetCoeff_Offset(eid);
            
            for(n = 0; n < nz_loc; ++n)
            {
                for(j = 0; j < nint; ++j)
                {
                    p_coeffs[n*totpcoeffs + cnt1+j] = 
                    f_p[cnt+j] = bnd[loctoglomap[offset + 
                    (nvel*nz_loc)*nbnd + 
                    n*nint + j]];
                }
                cnt += nint;
            }
            offset += (nvel*nbnd + nint)*nz_loc;
        }
        
        // Back solve first level of static condensation for interior
        // velocity space and store in F_int
        F_int = F_int + Transpose(*m_mat[mode].m_D_int)*F_p
        - Transpose(*m_mat[mode].m_Btilde)*F_bnd;
        F_int = (*m_mat[mode].m_Cinv)*F_int;
        
	curr_f_bnd = Eigen::VectorXd::Zero(f_bnd.num_elements());
	for (int i_phys_dof = 0; i_phys_dof < f_bnd.num_elements(); i_phys_dof++)
	{
		curr_f_bnd(i_phys_dof) = f_bnd[i_phys_dof]; 
	}
	curr_f_p = Eigen::VectorXd::Zero(f_p.num_elements()); 
	for (int i_phys_dof = 0; i_phys_dof < f_p.num_elements(); i_phys_dof++)
	{
		curr_f_p(i_phys_dof) = f_p[i_phys_dof]; 
	}
	curr_f_int = Eigen::VectorXd::Zero(f_int.num_elements()); 
	for (int i_phys_dof = 0; i_phys_dof < f_int.num_elements(); i_phys_dof++)
	{
		curr_f_int(i_phys_dof) = f_int[i_phys_dof]; 
	}



        // Unpack solution from Bnd and F_int to v_coeffs 
        cnt = cnt1 = 0;
        for(i = 0; i < nel; ++i) // loop over elements
        {
            eid  = i;
            fields[0]->GetExp(eid)->GetBoundaryMap(bmap);
            fields[0]->GetExp(eid)->GetInteriorMap(imap);
            nbnd   = bmap.num_elements();
            nint   = imap.num_elements();
            offset = fields[0]->GetCoeff_Offset(eid);
            
            for(j = 0; j < nvel; ++j) // loop over velocity fields 
            {
                for(n = 0; n < nz_loc; ++n)
                {
                    for(k = 0; k < nbnd; ++k)
                    {
                        fields[j]->SetCoeff(n*nplanecoeffs + 
                        offset+bmap[k],
                        f_bnd[cnt+k]);
	//		cout << "at SolveLinearNS, writing f_bnd " << f_bnd[cnt+k] << endl;
                    }
                    
                    for(k = 0; k < nint; ++k)
                    {
                        fields[j]->SetCoeff(n*nplanecoeffs + 
                        offset+imap[k],
                        f_int[cnt1+k]);
                    }
                    cnt  += nbnd;
                    cnt1 += nint;
                }
            }
        }
        
        for(j = 0; j < nvel; ++j) 
        {
            fields[j]->SetPhysState(false);
        }
    }
    

    void CoupledLinearNS_trafoP::DoInitialiseAdv(Array<OneD, NekDouble> myAdvField_x, Array<OneD, NekDouble> myAdvField_y)
    {
    	// only covers case eSteadyOseen

	// moved to .h	Array<OneD, Array<OneD, NekDouble> > myAdvField(2);
	myAdvField = Array<OneD, Array<OneD, NekDouble> > (2);
	myAdvField[0] = Array<OneD, NekDouble> (m_fields[0]->GetTotPoints(),0.0);
	myAdvField[1] = Array<OneD, NekDouble> (m_fields[0]->GetTotPoints(),0.0);
	Array<OneD, Array<OneD, NekDouble> > local_myAdvField(2);	
	local_myAdvField[0] = Array<OneD, NekDouble> (m_fields[0]->GetTotPoints(),0.0);
	local_myAdvField[1] = Array<OneD, NekDouble> (m_fields[0]->GetTotPoints(),0.0);
	for (int i = 0; i<m_fields[0]->GetTotPoints(); ++i)
	{
		myAdvField[0][i] = myAdvField_x[i];
		myAdvField[1][i] = myAdvField_y[i];
		local_myAdvField[0][i] = myAdvField_x[i];
		local_myAdvField[1][i] = myAdvField_y[i];

	}

        std::vector<std::string> fieldStr;
        for(int i = 0; i < m_velocity.num_elements(); ++i)
        {
             fieldStr.push_back(m_boundaryConditions->GetVariable(m_velocity[i]));
        }
//	cout << "fieldStr[0] " << fieldStr[0] << endl;
//        EvaluateFunction(fieldStr,AdvField,"AdvectionVelocity"); // defined in EquationSystem

        SetUpCoupledMatrix(0.0, local_myAdvField, false);

    }


    void CoupledLinearNS_trafoP::v_Output(void)
    {    
        std::vector<Array<OneD, NekDouble> > fieldcoeffs(m_fields.num_elements()+1);
        std::vector<std::string> variables(m_fields.num_elements()+1);
        int i;
        
        for(i = 0; i < m_fields.num_elements(); ++i)
        {
            fieldcoeffs[i] = m_fields[i]->UpdateCoeffs();
            variables[i]   = m_boundaryConditions->GetVariable(i);
        }
        
        fieldcoeffs[i] = Array<OneD, NekDouble>(m_fields[0]->GetNcoeffs());  
        // project pressure field to velocity space        
        if(m_singleMode==true)
        {
            Array<OneD, NekDouble > tmpfieldcoeffs (m_fields[0]->GetNcoeffs()/2);
            m_pressure->GetPlane(0)->BwdTrans_IterPerExp(m_pressure->GetPlane(0)->GetCoeffs(), m_pressure->GetPlane(0)->UpdatePhys());
            m_pressure->GetPlane(1)->BwdTrans_IterPerExp(m_pressure->GetPlane(1)->GetCoeffs(), m_pressure->GetPlane(1)->UpdatePhys()); 
            m_fields[0]->GetPlane(0)->FwdTrans_IterPerExp(m_pressure->GetPlane(0)->GetPhys(),fieldcoeffs[i]);
            m_fields[0]->GetPlane(1)->FwdTrans_IterPerExp(m_pressure->GetPlane(1)->GetPhys(),tmpfieldcoeffs);
            for(int e=0; e<m_fields[0]->GetNcoeffs()/2; e++)
            {
                fieldcoeffs[i][e+m_fields[0]->GetNcoeffs()/2] = tmpfieldcoeffs[e];
            }          
        }
        else
        {
            m_pressure->BwdTrans_IterPerExp(m_pressure->GetCoeffs(),m_pressure->UpdatePhys());
            m_fields[0]->FwdTrans_IterPerExp(m_pressure->GetPhys(),fieldcoeffs[i]);
        }
        variables[i] = "p"; 
        
        std::string outname = m_sessionName + ".fld";
        
        WriteFld(	outname,m_fields[0],fieldcoeffs,variables);
    }
    
    int CoupledLinearNS_trafoP::v_GetForceDimension()
    {
        return m_session->GetVariables().size();
    }
    
    void CoupledLinearNS_trafoP::WritePhysCoordIndicesMapping()
    {
    	MultiRegions::ExpListSharedPtr pressure_collector = GetPressure();   

        int nPoints = m_fields[0]->GetTotPoints();
        Array<OneD, NekDouble> coords0(nPoints);
        Array<OneD, NekDouble> coords1(nPoints);
        Array<OneD, NekDouble> coords2(nPoints);

        m_fields[0]->GetCoords(coords0, coords1, coords2);

        /*ofstream myfile ("mf0.txt");
      	if (myfile.is_open())
      	{
        	for (int counter = 0; counter < nPoints; ++counter)
        	{
        	    myfile << std::setprecision(17) << coords0[counter] << " ";
        	    myfile << std::setprecision(17) << coords1[counter] << " ";
       		    myfile << std::setprecision(17) << coords2[counter] << " ";
          	  myfile << "\n";
       		}
            myfile.close();
      	}
      	else cout << "Unable to open file";*/

        m_fields[1]->GetCoords(coords0, coords1, coords2);

        ofstream myfile1 ("mf1.txt");
      	if (myfile1.is_open())
      	{
        	for (int counter = 0; counter < nPoints; ++counter)
        	{
            	myfile1 << std::setprecision(17) << coords0[counter] << " ";
            	myfile1 << std::setprecision(17) << coords1[counter] << " ";
            	myfile1 << std::setprecision(17) << 0 /*coords2[counter]*/ << " "; //sometimes with low order polyn. and 2D domain it returns NaN and the file reader would have problems
            	myfile1 << "\n";
        	}
            myfile1.close();
      	}
      	else cout << "Unable to open file";

     /*   pressure_collector->GetCoords(coords0, coords1, coords2);

        ofstream myfile2 ("pc.txt");
      	if (myfile2.is_open())
      	{
        	for (int counter = 0; counter < nPoints; ++counter)
        	{
            	myfile2 << std::setprecision(17) << coords0[counter] << " ";
            	myfile2 << std::setprecision(17) << coords1[counter] << " ";
            	myfile2 << std::setprecision(17) << coords2[counter] << " ";
            	myfile2 << "\n";
        	}
            myfile2.close();
      	}
      	else cout << "Unable to open file";  */
    }
    
   Array<OneD, Array<OneD, Array<OneD, NekDouble> > > CoupledLinearNS_trafoP::Continuation_method(Eigen::VectorXd *params)
   {
   		double m_kinvisMin, m_KinvisPercentage, m_tol, m_maxIt, m_MatrixSetUpStep, m_Restart, step;
   		m_session->LoadParameter("KinvisMin", m_kinvisMin);
        m_session->LoadParameter("KinvisPercentage", m_KinvisPercentage);
        m_session->LoadParameter("Tolerance", m_tol);
        m_session->LoadParameter("MaxIteration", m_maxIt);
        m_session->LoadParameter("Restart", m_Restart);
        m_session->LoadParameter("KinvisStep", step);
        m_session->LoadParameter("UseDeflation", use_deflation);
        
        arclength_step = step;
        max_step = step;
        start_with_Oseen = false;
        step_multiplier = 1;
        
		sol_x_cont_defl = Array<OneD, Array<OneD, NekDouble> > (m_maxIt);
		sol_y_cont_defl = Array<OneD, Array<OneD, NekDouble> > (m_maxIt);
		
		sol_x_cont_defl[0] = Array<OneD, NekDouble> (GetNpoints(), 0.0);
		sol_y_cont_defl[0] = Array<OneD, NekDouble> (GetNpoints(), 0.0);                    	
		
		int deflated_solutions_found = 0, curr_i, indexFlip;
		int previous_step_solutions = 1, previous_previous_step_solutions = 0, last_bif_point_solutions_found = 0;  //number of solutions found in the step k-1 and k-2 when the current step is the k-th
		bool lost_solution = true, use_arclength, used_deflation;
		double last_param, last_real_delta_param = 0, real_delta_param, delta_param, csi, use_deflation_now = false, use_guessGivenNi = true;
		Array<OneD, NekDouble> guess_x, guess_y, guess_tmp;
		//Eigen::MatrixXd complete_matrix;
		total_solutions_found = 0;
		param_vector.resize(0);
		
		Set_m_kinvis((*params)[0]);// + step);
		std::vector<int> indices_to_be_continued; //for the next value of the parameter
		//std::vector<int> local_indices_to_be_continued(0); //for the current value of the parameter
		Array<OneD, Array<OneD, NekDouble> > converged_solution(2), possible_solutions;
		
		
		//int index = 43; // random number
		WritePhysCoordIndicesMapping();
			std::ifstream infile;
			infile.open("mf1.txt", std::ios::in);
			
			double x1,y1,z1;
			bool finished = false;
			//std::vector<int> flipperMap;
			std::vector<double> x, y;
			while(infile >> x1 >>y1 >> z1)
			{
				x.push_back(x1);
				y.push_back(y1);
			}
			flipperMap = GetFlipperMap(x,y); 
			
			deflate = false;
			//compute first solution
			cout<<"Compute first solution\n"<<endl;
			converged_solution = DoSolve_at_param_continuation(sol_x_cont_defl[0], sol_y_cont_defl[0], m_kinvis);
			for (int j=0; j < GetNpoints(); ++j)
			{
				sol_x_cont_defl[0][j] = converged_solution[0][j];
				sol_y_cont_defl[0][j] = converged_solution[1][j];
			}
			indices_to_be_continued.push_back(0);
			total_solutions_found = 1;
			last_param = m_kinvis;
			
			std::ofstream outfile;
			std::stringstream sstm;
			//sstm << "bif_diagr"<<second_param*1000<<".txt";
			sstm << "bif_diagr.txt";
			std::string outname0 = sstm.str();
			const char * outname1 = outname0.c_str();
			
			outfile.open(outname1, std::ios::out);
			
			std::ofstream outfile2;
			outfile2.open("arclength.txt", std::ios::out);
 
			//outfile<<m_kinvis<<" "<<sol_y_cont_defl[0][index]<<endl; 
			outfile2<<arclength_step<<endl; 
			param_vector.push_back(m_kinvis);
			total_solutions_found = 0;
			FarrelOutput(flipperMap, outfile, FarrelOutputSign(x,y));
			total_solutions_found = 1;
			
			while(m_kinvis > m_kinvisMin && total_solutions_found < m_maxIt)
			{
				local_indices_to_be_continued.resize(0);
				
				//continuation
				cout<<"\nBegin continuation"<<endl;			
				
				if(previous_step_solutions == previous_previous_step_solutions && !lost_solution) 
				{
					use_arclength = true;
					if(use_guessGivenNi)
					{
						real_delta_param = findMinParam(indices_to_be_continued);
						delta_param = max(m_kinvis/2000.0, min(step * m_kinvis, real_delta_param));
						cout<<"delta_param = "<<delta_param<<endl;
					}
				}
				else
				{
					use_arclength = false;
				}
				previous_previous_step_solutions = previous_step_solutions;
				previous_step_solutions = 0;
				deflate = false;
				//use_arclength = true;
				if(!(use_arclength && total_solutions_found>1))
				{
					Set_m_kinvis( m_kinvis * (1-step/2*(total_solutions_found>1)) );
					//Set_m_kinvis( m_kinvis - step );
				}
				for(int i = 0; i < indices_to_be_continued.size() && total_solutions_found < m_maxIt; i++)
				{		
					curr_i = indices_to_be_continued[i];
					if(use_arclength && total_solutions_found>1) // pseudo arc-length only if I didn't found or loose any solution  
					{					
						if(!use_guessGivenNi)
							ComputeContinuationGuess(curr_i, curr_i-previous_previous_step_solutions);
						else
						{
							ComputeContinuationGuessGivenNi(curr_i, curr_i-previous_previous_step_solutions, delta_param);
						}
						guess_x = sol_x_cont_defl[total_solutions_found];
						guess_y = sol_y_cont_defl[total_solutions_found];
						//cout<<"valore prima"<<guess_x[23]<<endl;
					}
					else
					{
						guess_x = sol_x_cont_defl[curr_i];
						guess_y = sol_y_cont_defl[curr_i];
						//cout<<"valore prima"<<guess_x[23]<<endl;
					}
					lost_solution = false;
					converged_solution = DoSolve_at_param_continuation(guess_x, guess_y, m_kinvis);
					if(converged)
					{
						sol_x_cont_defl[total_solutions_found] = Array<OneD, NekDouble> (GetNpoints(), 0.0);
						sol_y_cont_defl[total_solutions_found] = Array<OneD, NekDouble> (GetNpoints(), 0.0);
						
						double norma = 0;
						for (int j=0; j < GetNpoints(); ++j)
						{
							sol_x_cont_defl[total_solutions_found][j] = converged_solution[0][j];
							sol_y_cont_defl[total_solutions_found][j] = converged_solution[1][j];
							norma += (converged_solution[0][j] - guess_x[j]) * (converged_solution[0][j] - guess_x[j]) ;
							norma += (converged_solution[1][j] - guess_y[j]) * (converged_solution[1][j] - guess_y[j]) ;
						}
						cout<<"La norma é "<<norma<<" e un punto a caso vale "<<guess_x[23]<<" oppure "<<sol_x_cont_defl[curr_i][23]<<" -> "<<converged_solution[0][23]<<endl;
						local_indices_to_be_continued.push_back(total_solutions_found);
						param_vector.push_back(m_kinvis);
						//outfile<<m_kinvis<<" "<<sol_y_cont_defl[total_solutions_found][index]<<endl; 
						outfile2<<arclength_step<<endl; 
						FarrelOutput(flipperMap, outfile, FarrelOutputSign(x,y));
						total_solutions_found++;
						previous_step_solutions++;
					}
					else
					{
						lost_solution = true;
					}
					deflate = true;
					if(use_arclength && total_solutions_found>1 && use_guessGivenNi && i < indices_to_be_continued.size() - 1)
					{
						m_kinvis += delta_param;
					}
				}
				
				
				if(use_arclength)  // Change of arclength_step to improve the continuation and activate or deactivate deflation when I need it
				{
					//if(arclength_step * step_multiplier < max_step)
						//arclength_step *= step_multiplier; 
					cout<<"Step_multiplier = "<<step_multiplier<<endl;	
					used_deflation = use_deflation_now;
					if(step_multiplier < 0.75)
					{
						use_deflation_now = use_deflation;
					}
					else
					{
						use_deflation_now = false;
					}
					
					if(!used_deflation && use_deflation_now)
						last_bif_point_solutions_found = 0;
					if(last_bif_point_solutions_found > 1)
						use_deflation_now = false;
						
				}
				
				//deflation
				cout<<"\nBegin deflation"<<endl;
				deflate = use_deflation;
				int prev_solutions = local_indices_to_be_continued.size();
				
				//use_deflation_now = true;
				use_deflation_now = ((local_indices_to_be_continued.size()<3 && m_kinvis<0.97*second_param)|| (m_kinvis<0.405*second_param && local_indices_to_be_continued.size()<5));
				for(int i = 0; i < prev_solutions && use_deflation && use_deflation_now && total_solutions_found < m_maxIt; i++)
				{
					curr_i = local_indices_to_be_continued[i];
					converged = true;
					
					for (int j=0; j < GetNpoints(); ++j) 
					{
						guess_x[j] = sol_x_cont_defl[curr_i][j]*(1+(((double)rand())/RAND_MAX-0.5)/2/1e3);
						guess_y[j] = sol_y_cont_defl[curr_i][j]*(1+(((double)rand())/RAND_MAX-0.5)/2/1e3);
					}				
					
					while(converged && use_deflation_now)
					{
						converged_solution = DoSolve_at_param_continuation(guess_x, guess_y, m_kinvis);
						if(converged)
						{
							sol_x_cont_defl[total_solutions_found] = Array<OneD, NekDouble> (GetNpoints(), 0.0);
							sol_y_cont_defl[total_solutions_found] = Array<OneD, NekDouble> (GetNpoints(), 0.0);
							for (int j=0; j < GetNpoints(); ++j)
							{
								sol_x_cont_defl[total_solutions_found][j] = converged_solution[0][j];
								sol_y_cont_defl[total_solutions_found][j] = converged_solution[1][j];
							}
							local_indices_to_be_continued.push_back(total_solutions_found);
							param_vector.push_back(m_kinvis);
							//outfile<<m_kinvis<<" "<<sol_y_cont_defl[total_solutions_found][index]<<endl;
							outfile2<<arclength_step<<endl; 
							FarrelOutput(flipperMap, outfile, FarrelOutputSign(x,y));
							total_solutions_found++;
							previous_step_solutions++;
							last_bif_point_solutions_found++;
							
							indexFlip = 0;				
							possible_solutions = FlipAndCheck(flipperMap, &indexFlip);	
							if(indexFlip > 0) //I expect to flip at most 1 solution, so the first one in possible_solutions
							{
								guess_x = possible_solutions[0];
								guess_y = possible_solutions[1];
							}
						}
						use_deflation_now = ((local_indices_to_be_continued.size()<3 && m_kinvis<0.97*second_param)|| (m_kinvis<0.405*second_param && local_indices_to_be_continued.size()<5));
					}
					use_deflation_now = ((local_indices_to_be_continued.size()<3 && m_kinvis<0.97*second_param)|| (m_kinvis<0.405*second_param && local_indices_to_be_continued.size()<5));
				}
				
				//here I want to flip the solutions and check if they are different from the previous ones, if so I use them as initial guess trying to converge to new solutions
				cout<<"Do I want to flip? --> local_indices_to_be_continued.size() = "<<local_indices_to_be_continued.size() <<endl;
				if(local_indices_to_be_continued.size() % 2 == 0)
				{ 
					indexFlip = 0;				
					possible_solutions = FlipAndCheck(flipperMap, &indexFlip);
					last_param = m_kinvis;
				
					for(int i = 0; i < indexFlip && total_solutions_found < m_maxIt; i+=2)
					{	
						start_with_Oseen = true;
						//m_kinvis = possible_solutions[indexFlip][i/2];
						//Vmath::Vcopy(possible_solutions[i].num_elements(), possible_solutions[i], 1, m_fields[0]->UpdatePhys(), 1 );
						//Vmath::Vcopy(possible_solutions[i+1].num_elements(), possible_solutions[i+1], 1, m_fields[1]->UpdatePhys(), 1 );
						
						
						//m_fields[0]->FwdTrans(m_fields[0]->GetPhys(), m_fields[0]->UpdateCoeffs());
						//m_fields[1]->FwdTrans(m_fields[1]->GetPhys(), m_fields[1]->UpdateCoeffs());
						
						converged_solution = DoSolve_at_param_continuation(possible_solutions[i], possible_solutions[i+1], m_kinvis);
						if(converged)
						{
							sol_x_cont_defl[total_solutions_found] = Array<OneD, NekDouble> (GetNpoints(), 0.0);
							sol_y_cont_defl[total_solutions_found] = Array<OneD, NekDouble> (GetNpoints(), 0.0);
							for (int j=0; j < GetNpoints(); ++j)
							{
								sol_x_cont_defl[total_solutions_found][j] = converged_solution[0][j];
								sol_y_cont_defl[total_solutions_found][j] = converged_solution[1][j];
							}
							local_indices_to_be_continued.push_back(total_solutions_found);
							param_vector.push_back(m_kinvis);
							//outfile<<m_kinvis<<" "<<sol_y_cont_defl[total_solutions_found][index]<<endl; 
							outfile2<<arclength_step<<endl; 
							FarrelOutput(flipperMap, outfile, FarrelOutputSign(x,y));
							total_solutions_found++;
							previous_step_solutions++;
							last_bif_point_solutions_found++;
						}
					}
					m_kinvis = last_param;
					start_with_Oseen = false;  
				}  
				
				indices_to_be_continued.clear();
				indices_to_be_continued = std::vector<int>(local_indices_to_be_continued);
				//last_real_delta_param = delta_param;
			}
			outfile.close();
			outfile2.close();
			
			
		Array<OneD, Array<OneD, Array<OneD, NekDouble> > > result = Array<OneD, Array<OneD, Array<OneD, NekDouble> > > (2);
		result[0] = sol_x_cont_defl;
		result[1] = sol_y_cont_defl;	
		result[0] = Array<OneD, Array<OneD, NekDouble> > (total_solutions_found);
		result[1] = Array<OneD, Array<OneD, NekDouble> > (total_solutions_found);	
		
		params->resize(param_vector.size());		
		for(int i = 0; i < total_solutions_found; i++)
		{
			result[0][i] = 	sol_x_cont_defl[i];
			result[1][i] = 	sol_y_cont_defl[i];
			(*params)[i] = param_vector[i];
		}
		
		cout<<"\nEnd of continuation_method()\n";
 		return result;
   }
   
   
	std::vector<int> CoupledLinearNS_trafoP::GetFlipperMap(std::vector<double> &x, std::vector<double> &y)
	{
		std::vector<int> flipperMap;
		bool found;
		double tol = 1e-7, center = 3.75;
		
		for(int i = 0; i < x.size(); i++)
		{
			found = false;
			for(int j = 0; j < x.size() && !found; j++)
			{
				if(fabs(x[i]-x[j]) < tol && fabs((y[i]+y[j])/2.-center) < tol)
				{
					flipperMap.push_back(j);
					found = true;
				}
			}
		}
		return flipperMap;
	}
	
	//the output is the set of possible solutions (u1,v1,u2,v2,u3,v3,...) obtained flipping the previous ones, the last array contains the associated parameters
	Array<OneD, Array<OneD, NekDouble> > CoupledLinearNS_trafoP::FlipAndCheck(std::vector<int> &flipperMap, int *flipCounter)
	{
		Array<OneD, NekDouble> guess_tmp, guess_x, guess_y;
		unsigned int num_sol = local_indices_to_be_continued.size();
		Array<OneD, Array<OneD, NekDouble> > possible_solutions = Array<OneD, Array<OneD, NekDouble> >(2*num_sol );//+ 1) ;
		//possible_solutions[2*num_sol] = Array<OneD, NekDouble>(num_sol,0.0);
		double norm;
		bool possible;
		(*flipCounter) = 0;
		
		for(unsigned int j = 0; j < num_sol; j++)
		{
			guess_x = Array<OneD, NekDouble>(sol_x_cont_defl[0].num_elements(),0.0);
			guess_y = Array<OneD, NekDouble>(sol_x_cont_defl[0].num_elements(),0.0);
			unsigned int curr_j = local_indices_to_be_continued[j];
			
			//flip
			for(int i = 0; i < sol_x_cont_defl[curr_j].num_elements(); i++)
			{
				guess_x[i] += sol_x_cont_defl[curr_j][flipperMap[i]];
				guess_y[i] -= sol_y_cont_defl[curr_j][flipperMap[i]];
			}   
			
			//check
			possible = true;
			for(unsigned int k = 0; k < num_sol; k++)
			{
				norm = 0;
				int curr_k = local_indices_to_be_continued[k];
				for(unsigned int l = 0; l < sol_x_cont_defl[curr_k].num_elements(); l++)
				{
					norm += (guess_x[l]-sol_x_cont_defl[curr_k][l]) * (guess_x[l]-sol_x_cont_defl[curr_k][l]);
					norm += (guess_y[l]-sol_y_cont_defl[curr_k][l]) * (guess_y[l]-sol_y_cont_defl[curr_k][l]);
				}  
				norm = sqrt(norm)/(2*sol_x_cont_defl[curr_k].num_elements());
				cout<<"The norm of the difference between the solution "<<j<<" flipped and the solution "<<k<<" is "<<norm<<endl;
				if(norm < 1e-3)
					possible = false;
			}
			
			//add to possible_solutions if it is a new possible solution
			if(possible)
			{
				possible_solutions[(*flipCounter)] = Array<OneD, NekDouble>(sol_x_cont_defl[0].num_elements(),0.0);
				possible_solutions[(*flipCounter)+1] = Array<OneD, NekDouble>(sol_y_cont_defl[0].num_elements(),0.0);
				for(unsigned int i = 0; i < sol_x_cont_defl[curr_j].num_elements(); i++)
				{
					possible_solutions[(*flipCounter)][i] = guess_x[i];
					possible_solutions[(*flipCounter)+1][i] = guess_y[i];
				}
				//possible_solutions[2*num_sol][(*flipCounter)/2] = param_vector[curr_j]; 
				(*flipCounter) += 2;
			}
		}
		return possible_solutions;
	}
	
	void CoupledLinearNS_trafoP::FarrelOutput(std::vector<int> &flipperMap, std::ofstream &outfile, int sign)
	{
		Array<OneD, NekDouble> guess_tmp, sol_x, sol_y;
		sol_x = Array<OneD, NekDouble>(sol_x_cont_defl[0].num_elements(),0.0);
		//sol_y = Array<OneD, NekDouble>(sol_x_cont_defl[0].num_elements(),0.0);
		
		for(unsigned int i = 0; i < sol_x_cont_defl[0].num_elements(); i++)
		{
			sol_x[i] = sol_x_cont_defl[total_solutions_found][i] - sol_x_cont_defl[total_solutions_found][flipperMap[i]];
		}   
		
		for(unsigned int i = 0; i < sol_x_cont_defl[0].num_elements(); i++)
		{
			sol_x[i] = fabs(sol_x[i]);
		}   
		
		outfile<<m_kinvis<<" "<<sign * m_fields[0]->L2(sol_x)<<endl;
	}
	
	
	int CoupledLinearNS_trafoP::FarrelOutputSign(std::vector<double> &x, std::vector<double> &y)
	{
		double sign = 0;
		for(unsigned int i = 0; i < sol_y_cont_defl[0].num_elements(); i++)
		{
			sign += sol_y_cont_defl[total_solutions_found][i];
		}  
		return round(sign/fabs(sign));		
	}
	
	double CoupledLinearNS_trafoP::findMinParam(std::vector<int> &indices_to_be_continued)
	{
		// bordering algorithm present in Keller's book (with same notation) 
    	
    	Array<OneD, Array<OneD, NekDouble> > u_N(m_velocity.num_elements());
        Array<OneD, Array<OneD, NekDouble> > tmp_RHS(m_velocity.num_elements());
        Array<OneD, Array<OneD, NekDouble> > RHS(m_velocity.num_elements());
        Array<OneD, Array<OneD, NekDouble> > y(m_velocity.num_elements());
        Array<OneD, Array<OneD, NekDouble> > z(m_velocity.num_elements());
        Array<OneD, Array<OneD, NekDouble> > guess(m_velocity.num_elements());
        double csi_min = 1e20;
        unsigned int curr_i, prev_i;
        
        for(unsigned int j = 0 ; j < indices_to_be_continued.size(); j++)
        {
        	curr_i = indices_to_be_continued[j];
        	prev_i = curr_i - indices_to_be_continued.size();
        	
	        Array<OneD, NekDouble> cx(sol_x_cont_defl[curr_i].num_elements()); // I build the vector c using a secant method
	        Array<OneD, NekDouble> cy(sol_y_cont_defl[curr_i].num_elements());
	        
	        for(unsigned int i = 0; i < cx.num_elements(); i++)
	        	cx[i] = (sol_x_cont_defl[curr_i][i] - sol_x_cont_defl[prev_i][i])/(arclength_step);
	        for(unsigned int i = 0; i < cy.num_elements(); i++)
	        	cy[i] = (sol_y_cont_defl[curr_i][i] - sol_y_cont_defl[prev_i][i])/(arclength_step);
	        
	        guess[0] = Array<OneD, NekDouble> (m_fields[m_velocity[0]]->GetTotPoints(),0.0);
	        guess[1] = Array<OneD, NekDouble> (m_fields[m_velocity[1]]->GetTotPoints(),0.0);
	        guess[0] = sol_x_cont_defl[curr_i];
	        guess[1] = sol_y_cont_defl[curr_i];
	        
	        DoInitialiseAdv(guess[0], guess[1]);
	        DoSolve();
	        for(unsigned int i = 0; i < m_velocity.num_elements(); ++i)
	        {
	            z[i] = Array<OneD, NekDouble> (m_fields[m_velocity[i]]->GetTotPoints(),0.0);	
	            m_fields[m_velocity[i]]->BwdTrans_IterPerExp(m_fields[m_velocity[i]]->GetCoeffs(), z[i]);
	        } 	
	        
	        for(unsigned int i = 0; i < m_velocity.num_elements(); ++i)
	        {
	            //u_N[i] = Array<OneD, NekDouble> (m_fields[m_velocity[i]]->GetTotPoints(),0.0);	
	            //m_fields[m_velocity[i]]->BwdTrans_IterPerExp(m_fields[m_velocity[i]]->GetCoeffs(), u_N[i]);
	            
	            u_N[i] = guess[i];
	            
	            RHS[i] = Array<OneD, NekDouble> (m_fields[m_velocity[i]]->GetTotPoints(),0.0);	
	            tmp_RHS[i] = Array<OneD, NekDouble> (m_fields[m_velocity[i]]->GetTotPoints(),0.0);	
	            
	            m_fields[m_velocity[i]]->PhysDeriv(i, u_N[i], tmp_RHS[i]);
	            Vmath::Smul(tmp_RHS[i].num_elements(), m_kinvis, tmp_RHS[i], 1, tmp_RHS[i], 1);
	            //Vmath::Smul(tmp_RHS[i].num_elements(), param_vector[curr_i], tmp_RHS[i], 1, tmp_RHS[i], 1);
	            
	            bool waveSpace = m_fields[m_velocity[i]]->GetWaveSpace();
	            m_fields[m_velocity[i]]->SetWaveSpace(true);
	            m_fields[m_velocity[i]]->IProductWRTDerivBase(i, tmp_RHS[i], RHS[i]);
	            m_fields[m_velocity[i]]->SetWaveSpace(waveSpace);
	        }
	        
	        SetUpCoupledMatrix(0.0, u_N, true);
	        SolveLinearNS(RHS);
	        
	        for(unsigned int i = 0; i < m_velocity.num_elements(); ++i)
	        {
	            y[i] = Array<OneD, NekDouble> (m_fields[m_velocity[i]]->GetTotPoints(),0.0);	
	            m_fields[m_velocity[i]]->BwdTrans_IterPerExp(m_fields[m_velocity[i]]->GetCoeffs(), y[i]);
	            
	            Vmath::Smul(y[i].num_elements(), m_kinvis, y[i], 1, y[i], 1);
	            //Vmath::Smul(y[i].num_elements(), param_vector[curr_i], y[i], 1, y[i], 1);
	            Vmath::Vadd(y[i].num_elements(), y[i], 1, u_N[i], 1, y[i], 1);
	            
	            //m_fields[m_velocity[i]]->FwdTrans(u_star[i], m_fields[m_velocity[i]]->UpdateCoeffs());
	            //m_fields[m_velocity[i]]->BwdTrans(m_fields[m_velocity[i]]->GetCoeffs(), m_fields[m_velocity[i]]->UpdatePhys());
	        }
	        for(unsigned int i = 0; i < guess.num_elements(); i++)
	        {
	        	guess[i] = y[i];
	        }
	        
	        double c_dot_z, c_dot_y, csi;
	        c_dot_z = Vmath::Dot(cx.num_elements(), cx, z[0]);
	        c_dot_z += Vmath::Dot(cy.num_elements(), cy, z[1]);
	        
	        c_dot_y = Vmath::Dot(cx.num_elements(), cx, y[0]);
	        c_dot_y += Vmath::Dot(cy.num_elements(), cy, y[1]);
	        
	        csi = (arclength_step - c_dot_z) / ((param_vector[curr_i] - param_vector[prev_i])/arclength_step - c_dot_y);
	        if(fabs(csi) < csi_min)
	        	csi_min = csi;
        }
        return csi_min;
	}
	
	void CoupledLinearNS_trafoP::ComputeContinuationGuessGivenNi(int curr_i, int prev_i, double delta_param)
	{		
    	/*Array<OneD, Array<OneD, NekDouble> > u_N(m_velocity.num_elements());
        Array<OneD, Array<OneD, NekDouble> > tmp_RHS(m_velocity.num_elements());
        Array<OneD, Array<OneD, NekDouble> > RHS(m_velocity.num_elements());
        Array<OneD, Array<OneD, NekDouble> > guess(m_velocity.num_elements());
		guess[0] = Array<OneD, NekDouble> (m_fields[m_velocity[0]]->GetTotPoints(),0.0);
        guess[1] = Array<OneD, NekDouble> (m_fields[m_velocity[1]]->GetTotPoints(),0.0);
        
        guess[0] = sol_x_cont_defl[curr_i];
        guess[1] = sol_y_cont_defl[curr_i];
        
		const unsigned int ncmpt = m_velocity.num_elements();
        Array<OneD, Array<OneD, NekDouble> > forcing_phys(ncmpt);
        Array<OneD, Array<OneD, NekDouble> > forcing     (ncmpt);

        for(unsigned int i = 0; i < ncmpt; ++i)
        {
            forcing_phys[i] = Array<OneD, NekDouble> (m_fields[m_velocity[0]]->GetNpoints(), 0.0);
            forcing[i]      = Array<OneD, NekDouble> (m_fields[m_velocity[0]]->GetNcoeffs(),0.0);
        }

        std::vector<SolverUtils::ForcingSharedPtr>::const_iterator x;
        for (x = m_forcing.begin(); x != m_forcing.end(); ++x)
        {
            const NekDouble time = 0;
            (*x)->Apply(m_fields, forcing_phys, forcing_phys, time);
        }

        Array<OneD, Array<OneD, NekDouble> > AdvField(m_velocity.num_elements());
		Array<OneD, Array<OneD, NekDouble> > Eval_Adv(m_velocity.num_elements());
		Array<OneD, Array<OneD, NekDouble> > AdvTerm(m_velocity.num_elements());
        for(unsigned int il = 0; il < m_velocity.num_elements(); ++il)
        {
            AdvField[il] = Array<OneD, NekDouble> (m_fields[m_velocity[il]]->GetTotPoints(),0.0);
			Eval_Adv[il] = Array<OneD, NekDouble> (m_fields[m_velocity[il]]->GetTotPoints(),0.0);
			AdvTerm[il] = Array<OneD, NekDouble> (m_fields[m_velocity[il]]->GetNcoeffs(),0.0);
        }
                 
        ASSERTL0(m_session->DefinesFunction("AdvectionVelocity"),
             "Advection Velocity section must be defined in "
             "session file.");
                 
        std::vector<std::string> fieldStr;
        for(unsigned int il = 0; il < m_velocity.num_elements(); ++il)
        {
        	fieldStr.push_back(m_boundaryConditions->GetVariable(m_velocity[il]));
        }
        EvaluateFunction(fieldStr,AdvField,"AdvectionVelocity");

		// here myAdvField
		EvaluateAdvectionTerms(myAdvField, Eval_Adv);
		// actually have the right Adv velo

        for (unsigned int i = 0; i < ncmpt; ++i)
        {
            bool waveSpace = m_fields[m_velocity[i]]->GetWaveSpace();
            m_fields[i]->SetWaveSpace(true);
            m_fields[i]->IProductWRTBase(forcing_phys[i], forcing[i]);
            m_fields[m_velocity[i]]->IProductWRTBase(Eval_Adv[i], AdvTerm[i]); //(w, (u.grad)u)
	    	if (use_Newton)
	    	{
				for (unsigned int il = 0; il < forcing[i].num_elements(); ++il)
	        	{
					forcing[i][il] = forcing[i][il] - AdvTerm[i][il];
				}
	    	}
        	m_fields[i]->SetWaveSpace(waveSpace);
        }
        
        for(unsigned int i = 0; i < ncmpt; ++i)
        {
            u_N[i] = guess[i];
            
            RHS[i] = Array<OneD, NekDouble> (m_fields[m_velocity[i]]->GetTotPoints(),0.0);	
            tmp_RHS[i] = Array<OneD, NekDouble> (m_fields[m_velocity[i]]->GetTotPoints(),0.0);	
            
            m_fields[m_velocity[i]]->PhysDeriv(i, u_N[i], tmp_RHS[i]);
            Vmath::Smul(tmp_RHS[i].num_elements(), m_kinvis * delta_param, tmp_RHS[i], 1, tmp_RHS[i], 1);
            
            bool waveSpace = m_fields[m_velocity[i]]->GetWaveSpace();
            m_fields[m_velocity[i]]->SetWaveSpace(true);
            m_fields[m_velocity[i]]->IProductWRTDerivBase(i, tmp_RHS[i], RHS[i]);
            m_fields[m_velocity[i]]->SetWaveSpace(waveSpace);
            
            Vmath::Vsub(tmp_RHS[i].num_elements(),forcing[i],1,RHS[i],1,RHS[i],1);
        }
        
        SetUpCoupledMatrix(0.0, u_N, true);
        SolveLinearNS(RHS);
        
        sol_x_cont_defl[total_solutions_found] = Array<OneD, NekDouble>(sol_x_cont_defl[0].num_elements(),0.0);	
        sol_y_cont_defl[total_solutions_found] = Array<OneD, NekDouble>(sol_y_cont_defl[0].num_elements(),0.0);	
        
        m_fields[0]->BwdTrans(m_fields[0]->GetCoeffs(), m_fields[0]->UpdatePhys());
        m_fields[1]->BwdTrans(m_fields[1]->GetCoeffs(), m_fields[1]->UpdatePhys());
        
		CopyFromPhysField(0, sol_x_cont_defl[total_solutions_found]); 
		CopyFromPhysField(1, sol_y_cont_defl[total_solutions_found]);	
        
        m_kinvis -= delta_param;*/
        
    	
    	Array<OneD, Array<OneD, NekDouble> > u_N(m_velocity.num_elements());
        Array<OneD, Array<OneD, NekDouble> > tmp_RHS(m_velocity.num_elements());
        Array<OneD, Array<OneD, NekDouble> > RHS(m_velocity.num_elements());
        Array<OneD, Array<OneD, NekDouble> > y(m_velocity.num_elements());
        Array<OneD, Array<OneD, NekDouble> > z(m_velocity.num_elements());
        Array<OneD, Array<OneD, NekDouble> > guess(m_velocity.num_elements());
        
        sol_x_cont_defl[total_solutions_found] = Array<OneD, NekDouble>(sol_x_cont_defl[0].num_elements(),0.0);	
        sol_y_cont_defl[total_solutions_found] = Array<OneD, NekDouble>(sol_y_cont_defl[0].num_elements(),0.0);	
        
        Array<OneD, NekDouble> cx(sol_x_cont_defl[curr_i].num_elements()); // I build the vector c using a secant method
        Array<OneD, NekDouble> cy(sol_y_cont_defl[curr_i].num_elements());
        for(int i = 0; i < cx.num_elements(); i++)
        	cx[i] = (sol_x_cont_defl[curr_i][i] - sol_x_cont_defl[prev_i][i])/(arclength_step);
        for(int i = 0; i < cy.num_elements(); i++)
        	cy[i] = (sol_y_cont_defl[curr_i][i] - sol_y_cont_defl[prev_i][i])/(arclength_step);
        
        guess[0] = Array<OneD, NekDouble> (m_fields[m_velocity[0]]->GetTotPoints(),0.0);
        guess[1] = Array<OneD, NekDouble> (m_fields[m_velocity[1]]->GetTotPoints(),0.0);
        
        guess[0] = sol_x_cont_defl[curr_i];
        guess[1] = sol_y_cont_defl[curr_i];
        
        DoInitialiseAdv(guess[0], guess[1]);
        DoSolve();
        for(int i = 0; i < m_velocity.num_elements(); ++i)
        {
            z[i] = Array<OneD, NekDouble> (m_fields[m_velocity[i]]->GetTotPoints(),0.0);	
            m_fields[m_velocity[i]]->BwdTrans_IterPerExp(m_fields[m_velocity[i]]->GetCoeffs(), z[i]);
        } 	
        
        for(int i = 0; i < m_velocity.num_elements(); ++i)
        {
            u_N[i] = guess[i];
            
            RHS[i] = Array<OneD, NekDouble> (m_fields[m_velocity[i]]->GetTotPoints(),0.0);	
            tmp_RHS[i] = Array<OneD, NekDouble> (m_fields[m_velocity[i]]->GetTotPoints(),0.0);	
            
            m_fields[m_velocity[i]]->PhysDeriv(i, u_N[i], tmp_RHS[i]);
            Vmath::Smul(tmp_RHS[i].num_elements(), m_kinvis, tmp_RHS[i], 1, tmp_RHS[i], 1);
            
            bool waveSpace = m_fields[m_velocity[i]]->GetWaveSpace();
            m_fields[m_velocity[i]]->SetWaveSpace(true);
            m_fields[m_velocity[i]]->IProductWRTDerivBase(i, tmp_RHS[i], RHS[i]);
            m_fields[m_velocity[i]]->SetWaveSpace(waveSpace);
        }
        
        SetUpCoupledMatrix(0.0, u_N, true);
        SolveLinearNS(RHS);
        
        for(int i = 0; i < m_velocity.num_elements(); ++i)
        {
            y[i] = Array<OneD, NekDouble> (m_fields[m_velocity[i]]->GetTotPoints(),0.0);	
            m_fields[m_velocity[i]]->BwdTrans_IterPerExp(m_fields[m_velocity[i]]->GetCoeffs(), y[i]);
            
            //Vmath::Smul(y[i].num_elements(), m_kinvis, y[i], 1, y[i], 1);
            //Vmath::Vadd(y[i].num_elements(), y[i], 1, u_N[i], 1, y[i], 1);
        }
        
        for(int i = 0; i < guess.num_elements(); i++)
        {
        	Vmath::Smul(y[i].num_elements(), delta_param, y[i], 1, y[i], 1);
        	Vmath::Vsub(y[i].num_elements(), z[i], 1, u_N[i], 1, z[i], 1);
    	}
       
		
        for(int i = 0; i < sol_x_cont_defl[total_solutions_found].num_elements(); i++)
        {
        	sol_x_cont_defl[total_solutions_found][i] = sol_x_cont_defl[curr_i][i] + z[0][i];
        	sol_y_cont_defl[total_solutions_found][i] = sol_y_cont_defl[curr_i][i] + z[1][i];
        }  
        m_kinvis -= delta_param;
        
        m_fields[0]->FwdTrans(sol_x_cont_defl[total_solutions_found], m_fields[0]->UpdateCoeffs());
        m_fields[1]->FwdTrans(sol_y_cont_defl[total_solutions_found], m_fields[1]->UpdateCoeffs());
        
        m_fields[0]->BwdTrans(m_fields[0]->GetCoeffs(), m_fields[0]->UpdatePhys());
        m_fields[1]->BwdTrans(m_fields[1]->GetCoeffs(), m_fields[1]->UpdatePhys());
        
        cout<<"end of ComputeContinuationGuessGivenNi with m_kinvis = "<<m_kinvis<<endl;
	}

}

/**
 * $Log: CoupledLinearNS_trafoP.cpp,v $
 **/
