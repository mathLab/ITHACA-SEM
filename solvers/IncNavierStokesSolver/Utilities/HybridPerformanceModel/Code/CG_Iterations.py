# Andrew Gloster
# Summer 2016
# Python Version of Communication Model Implementation
# Code to examine CG iteration information generated by Nektar


# This code is stand alone and seperate from the main program, its
# is for showing the various features in the report relating to the 
# CG iterations

#------------------------------------
# Import relevant modules
#------------------------------------

import os
import matplotlib.pyplot as plt
import numpy as np

#------------------------------------
# Import relevant functions
#------------------------------------

from functions_main import Filename_Generate
from functions_main import Find_Nektar_Files

#------------------------------------
# New Function
#------------------------------------

# Pharse the Nektar CG iterations information for all modes. 
def Parse_Nektar_Output(Input_Filename, Skip_Steps):

    # Open file to be pharsed
    f = open(Input_Filename, "r")
    
    # List for outputs
    Times = []

    # We use dictionaries to generate look up tables of the CG information
    Pressure = {}
    Velocity_1 = {}
    Velocity_2 = {}
    Velocity_3 = {}

    # Count timestep we're on
    count = 0

    # Pharse desired data
    for line in f:
        a = line.split()
        for i in range(0, len(a)):
            
            # Iterate the timestep counter every time the file hits 'Pressure'
            if (a[i] == 'Pressure'):
                Velocity = False

                # Var is iterated depending on pressure or velocity being read in
                var = 1
                count += 1
                continue
            
            # Skip these time steps as they contain all the start up computations
            if (count <= Skip_Steps):
                continue

            if (a[i] == 'Velocity'):
                Velocity = True
                var = 1
                continue
            
            # Record the plane number
            if (a[i] == 'Plane'):
                plane = a[i + 1]

                if Velocity is True and plane == '0':
                    var += 1

                continue

            # Append each value of CG to the dictionaries
            if (a[i] == 'CG'):
                if (var == 1):
                    if plane in Pressure.keys():
                        Pressure[plane].append(int(a[i + 4]))
                        continue
                    else:
                        Pressure[plane] = [int(a[i + 4])]

                if (var == 2):
                    if plane in Velocity_1.keys():
                        Velocity_1[plane].append(int(a[i + 4]))
                        continue
                    else:
                        Velocity_1[plane] = [int(a[i + 4])]

                if (var == 3):
                    if plane in Velocity_2.keys():
                        Velocity_2[plane].append(int(a[i + 4]))
                        continue
                    else:
                        Velocity_2[plane] = [int(a[i + 4])]

                if (var == 4):
                    if plane in Velocity_3.keys():
                        Velocity_3[plane].append(int(a[i + 4]))
                        continue
                    else:
                        Velocity_3[plane] = [int(a[i + 4])]

    
    
    # Return the dictionaries of CG iteration
    return(Pressure, Velocity_1, Velocity_2, Velocity_3)

#------------------------------------
# Functions end here
#------------------------------------

#------------------------------------
# Program begins here
#------------------------------------

# Input the mesh file name, stored in Input/Mesh/
Mesh = 'cyl-small.xml'

# Maximum value of N_Z
Max_N_Z = 'output_72.txt'

# Input the conditions file name stored in Input/Conditions/
Conditions_File = 'conditions_80.xml'

# Choose the numerical scheme you're using, IterativeFull or IterativeStaticCond
Scheme = 'IterativeStaticCond'

# Select the values of N_Z you wish to calibrate the model with
Consider_Modes = [80]

# Choose number of constant to fit to the serial model model, 1 or 2
Num_Constants = 2

# Do you wish to run the clearcomparison between the calibrated serial model prediction and the collected data.
# Set to false if your serial data was collected to a different core than the one you are calibrating for.
Compare_Serial = False

# Do you wish to run the parallel portion of the model
Parallel = True

# Choose the Parallelisation method for the model to adopt, Modal, Elemental, Hybrid_Socket or Hybrid_Node 
Parallelisation = 'Hybrid_Socket'

# Do you wish to run the comparison between the full model prediction and the collected data
Compare_Parallel = True

# Input number of nodes you are using (Can replace this with PBS_Job_Parse)
Num_Node = 1

#------------------------------------
# Generate Input Filename Locations
#------------------------------------

(Mesh_File, Input_Nektar_Max, Conditions, Loc_Serial_Timing_Files, Loc_Parallel_Timing_Files, Benchmark_PBS, MPI_Benchmark, Node_Map) = Filename_Generate(Mesh, Max_N_Z, Conditions_File)

#------------------------------------
# Generate Output Locations
#------------------------------------

output_path = 'Output/Figures/Max_Min_CG/'
if os.path.exists(output_path):
    cmd_string_clear = 'rm -r Output/Figures/Max_Min_CG/ \n'
    process = Popen([cmd_string_clear],shell=True, stdout=PIPE, stdin=PIPE)
    process.wait()
    os.mkdir(output_path)
    
if not os.path.exists(output_path):
    os.mkdir(output_path)

output_path = 'Output/Figures/Stats/'
if os.path.exists(output_path):
    cmd_string_clear = 'rm -r Output/Figures/Stats/ \n'
    process = Popen([cmd_string_clear],shell=True, stdout=PIPE, stdin=PIPE)
    process.wait()
    os.mkdir(output_path)
    
if not os.path.exists(output_path):
    os.mkdir(output_path)

output_path = 'Output/Figures/Settling_Time/'
if os.path.exists(output_path):
    cmd_string_clear = 'rm -r Output/Figures/Settling_Time/ \n'
    process = Popen([cmd_string_clear],shell=True, stdout=PIPE, stdin=PIPE)
    process.wait()
    os.mkdir(output_path)
    
if not os.path.exists(output_path):
    os.mkdir(output_path)
    
#------------------------------------
# Pharse Serial Nektar Inputs
#------------------------------------

(Nektar_Modes, Timing_Files) = Find_Nektar_Files(Loc_Serial_Timing_Files)

# Lists for holding data
Pressure = []
Velocity_1 = []
Velocity_2 = []
Velocity_3 = []

Pressure_Key = []
Velocity_1_Key = []
Velocity_2_Key = []
Velocity_3_Key = []

Max_Pressure_CG = []
Max_Velocity_1_CG = []
Max_Velocity_2_CG = []
Max_Velocity_3_CG = []

Min_Pressure_CG = []
Min_Velocity_1_CG = []
Min_Velocity_2_CG = []
Min_Velocity_3_CG = []

# Number of timesteps to be skipped by default, contain no useful information
Skip_Steps = 20

# Phasre the data
for i in range(0, len(Timing_Files)):
    (pressure, velocity_1, velocity_2, velocity_3) = Parse_Nektar_Output(Loc_Serial_Timing_Files + Timing_Files[i], Skip_Steps)
    
    Pressure.append(pressure)
    Velocity_1.append(velocity_1)
    Velocity_2.append(velocity_2)
    Velocity_3.append(velocity_3)

#------------------------------------
# Produce plots of Max/Min Iterations
#------------------------------------

# Loop over files to produce plots of max and min CG iterations
for i in range(0, len(Timing_Files)):

#------------------------------------
# Pressure
#------------------------------------

    # Find the available keys from the relevant dictionary
    key_P = map(int, Pressure[i].keys())
    key_V_1 = map(int, Velocity_1[i].keys())
    key_V_2 = map(int, Velocity_2[i].keys())
    key_V_3 = map(int, Velocity_3[i].keys())

    # Sort this list
    key_P.sort()
    key_V_1.sort()
    key_V_2.sort()
    key_V_3.sort()
 
    # Lists for max and min CG iterations
    CG_Min_Pressure = []
    CG_Max_Pressure = []

    CG_Min_Velocity_1 = []
    CG_Max_Velocity_1 = []

    CG_Min_Velocity_2 = []
    CG_Max_Velocity_2 = []

    CG_Min_Velocity_3 = []
    CG_Max_Velocity_3 = []

    # Loop over the relevant data 
    for j in range(0, len(key_V_2)):
        CG_Max_Pressure.append(max(Pressure[i][str(key_P[j])]))
        CG_Min_Pressure.append(min(Pressure[i][str(key_P[j])]))

        CG_Max_Velocity_1.append(max(Velocity_1[i][str(key_V_1[j])]))
        CG_Min_Velocity_1.append(min(Velocity_1[i][str(key_V_1[j])]))

        CG_Max_Velocity_2.append(max(Velocity_2[i][str(key_V_2[j])]))
        CG_Min_Velocity_2.append(min(Velocity_2[i][str(key_V_2[j])]))

        CG_Max_Velocity_3.append(max(Velocity_3[i][str(key_V_3[j])]))
        CG_Min_Velocity_3.append(min(Velocity_3[i][str(key_V_3[j])]))

    # Store the max and min lists for later use
    Max_Pressure_CG.append(CG_Max_Pressure)
    Min_Pressure_CG.append(CG_Min_Pressure)   

    Max_Velocity_1_CG.append(CG_Max_Velocity_1)
    Min_Velocity_1_CG.append(CG_Min_Velocity_1)
    
    Max_Velocity_2_CG.append(CG_Max_Velocity_2)
    Min_Velocity_2_CG.append(CG_Min_Velocity_2)

    Max_Velocity_3_CG.append(CG_Max_Velocity_3)
    Min_Velocity_3_CG.append(CG_Min_Velocity_3)

    # Shift the key so they can be plotted correctly
    key_P = [x + 1 for x in key_P]
    key_V_1 = [x + 1 for x in key_V_1]
    key_V_2 = [x + 1 for x in key_V_2]
    key_V_3 = [x + 1 for x in key_V_3]

    # Store these for later use
    Pressure_Key.append(key_P)
    Velocity_1_Key.append(key_V_1)
    Velocity_2_Key.append(key_V_2)
    Velocity_3_Key.append(key_V_3)

    # Generate Save File and Title 
    savefile = 'Output/Figures/Max_Min_CG/Min_CG' + '_' + str(Nektar_Modes[i]) + '.png'
    title = 'Minimum CG Iterations: ' + 'Planes = ' + str(Nektar_Modes[i])
    
    # Produce the Plot
    fig, ax = plt.subplots()
    ax.plot(key_P, CG_Min_Pressure, label = 'Pressure')
    ax.plot(key_V_1, CG_Min_Velocity_1, label = 'Velocity_1')
    ax.plot(key_V_2, CG_Min_Velocity_2, label = 'Velocity_2')
    ax.plot(key_V_3, CG_Min_Velocity_3, label = 'Velocity_3')
    ax.set_xlabel('Plane Number')
    ax.set_ylabel('Minimum CG Iterations')
    plt.legend(loc=1)
    ax.set_title(title)

    if (Scheme == 'IterativeFull' and Mesh == 'Pipe'):
        ax.set_ylim([0,1000])

    if (Scheme == 'IterativeFull' and Mesh == 'Cylinder'):
        ax.set_ylim([0,1000])

    if (Scheme == 'IterativeStaticCond' and Mesh == 'Pipe'):
        ax.set_ylim([0,300])

    if (Scheme == 'IterativeStaticCond' and Mesh == 'Cylinder'):
        ax.set_ylim([0,300])

    fig.savefig(savefile)
    plt.close(fig)
    
    # Generate Save File and Title
    savefile = 'Output/Figures/Max_Min_CG/Max_CG' + '_' + str(Nektar_Modes[i]) + '.png'
    title = 'Maximum CG Iterations: ' + 'Planes = ' + str(Nektar_Modes[i])

    # Produce the Plot
    fig, ax = plt.subplots()
    ax.plot(key_P, CG_Max_Pressure, label = 'Pressure')
    ax.plot(key_V_1, CG_Max_Velocity_1, label = 'Velocity_1')
    ax.plot(key_V_2, CG_Max_Velocity_2, label = 'Velocity_2')
    ax.plot(key_V_3, CG_Max_Velocity_3, label = 'Velocity_3')
    ax.set_xlabel('Plane Number')
    ax.set_ylabel('Maximum CG Iterations')
    plt.legend(loc=1)
    ax.set_title(title)

    if (Scheme == 'IterativeFull' and Mesh == 'Pipe'):
        ax.set_ylim([0,1000])

    if (Scheme == 'IterativeFull' and Mesh == 'Cylinder'):
        ax.set_ylim([0,1000])

    if (Scheme == 'IterativeStaticCond' and Mesh == 'Pipe'):
        ax.set_ylim([0,300])

    if (Scheme == 'IterativeStaticCond' and Mesh == 'Cylinder'):
        ax.set_ylim([0,300])

    ax.set_title(title)
    fig.savefig(savefile)
    plt.close(fig)

# --------------------------------------
# Create a list of all the modes up to maximum
# --------------------------------------

# Find the max
max_modes = len(Pressure[len(Timing_Files) - 1]) + 1

# List of the modes
modes = []

# Generate the data
for i in range(1, max_modes + 1):

    # This mode is never included
    if (i == 2):
        continue

    modes.append(i)

# --------------------------------------
# Statistics of Max CG Iterations
# --------------------------------------

# Lists to store the data
data_mean = [[], [], [], []]
data_std_dev = [[], [], [], []]
data_var = [[], [], [], []]

# Find the relvant maximums across all the modes and find statistics of these
for j in range(0, len(Pressure[len(Timing_Files) - 1])):

    # List to hold the relvant data
    Data_P = []
    Data_V_1 = []
    Data_V_2 = []
    Data_V_3 = []

    # Loop finding the maximums for the given mode
    for i in range(0, len(Timing_Files)):

        # Not all have the same number of modes available, hence try used here
        try:
            Data_P.append(Max_Pressure_CG[i][j])
        except:
            continue

        try:
            Data_V_1.append(Max_Velocity_1_CG[i][j])
        except:
            continue

        try:
            Data_V_2.append(Max_Velocity_2_CG[i][j])
        except:
            continue

        try:
            Data_V_3.append(Max_Velocity_3_CG[i][j])
        except:
            continue

    # Find the mean, standard deviation and variance
    data_mean[0].append(np.mean(Data_P))
    data_std_dev[0].append(np.std(Data_P))
    data_var[0].append(np.var(Data_P))

    data_mean[1].append(np.mean(Data_V_1))
    data_std_dev[1].append(np.std(Data_V_1))
    data_var[1].append(np.var(Data_V_1))
    
    data_mean[2].append(np.mean(Data_V_2))
    data_std_dev[2].append(np.std(Data_V_2))
    data_var[2].append(np.var(Data_V_2))
    
    data_mean[3].append(np.mean(Data_V_3))
    data_std_dev[3].append(np.std(Data_V_3))
    data_var[3].append(np.var(Data_V_3))

# Produce the Plot
fig, ax = plt.subplots()
ax.plot(modes, data_mean[0], label = 'Pressure')
ax.plot(modes, data_mean[1], label = 'Velocity 1')
ax.plot(modes, data_mean[2], label = 'Velocity 2')
ax.plot(modes, data_mean[3], label = 'Velocity 3')
ax.set_xlabel('Plane Number')
ax.set_ylabel('Mean')
ax.set_title('Mean of Maximum Iterations vs Plane Number')
plt.legend(loc=1)

if (Scheme == 'IterativeFull' and Mesh == 'Pipe'):
    ax.set_ylim([0,1000])

if (Scheme == 'IterativeFull' and Mesh == 'Cylinder'):
    ax.set_ylim([0,1000])

if (Scheme == 'IterativeStaticCond' and Mesh == 'Pipe'):
    ax.set_ylim([0,300])

if (Scheme == 'IterativeStaticCond' and Mesh == 'Cylinder'):
    ax.set_ylim([0,300])

fig.savefig('Output/Figures/Stats/Max_Mean.png')
plt.close(fig)

# Produce the Plot
fig, ax = plt.subplots()
ax.plot(modes, data_std_dev[0], label = 'Pressure')
ax.plot(modes, data_std_dev[1], label = 'Velocity 1')
ax.plot(modes, data_std_dev[2], label = 'Velocity 2')
ax.plot(modes, data_std_dev[3], label = 'Velocity 3')
ax.set_xlabel('Plane Number')
ax.set_ylabel('Standard Deviation')
ax.set_title('Standard Deviation of Maximum Iterations vs Plane Number')
plt.legend(loc=1)

if (Scheme == 'IterativeFull' and Mesh == 'Pipe'):
    ax.set_ylim([-1,100])

if (Scheme == 'IterativeFull' and Mesh == 'Cylinder'):
    ax.set_ylim([-1,50])

if (Scheme == 'IterativeStaticCond' and Mesh == 'Pipe'):
    ax.set_ylim([-1,50])

if (Scheme == 'IterativeStaticCond' and Mesh == 'Cylinder'):
    ax.set_ylim([-1,10])

fig.savefig('Output/Figures/Stats/Max_Std_Dev.png')
plt.close(fig)

# Produce the Plot
fig, ax = plt.subplots()
ax.plot(modes, data_var[0], label = 'Pressure')
ax.plot(modes, data_var[1], label = 'Velocity 1')
ax.plot(modes, data_var[2], label = 'Velocity 2')
ax.plot(modes, data_var[3], label = 'Velocity 3')
ax.set_xlabel('Plane Number')
ax.set_ylabel('Variance')
ax.set_title('Variance of Maximum Iterations vs Plane Number')

if (Scheme == 'IterativeFull' and Mesh == 'Pipe'):
    ax.set_ylim([-1,100])

if (Scheme == 'IterativeFull' and Mesh == 'Cylinder'):
    ax.set_ylim([-1,50])

if (Scheme == 'IterativeStaticCond' and Mesh == 'Pipe'):
    ax.set_ylim([-1,50])

if (Scheme == 'IterativeStaticCond' and Mesh == 'Cylinder'):
    ax.set_ylim([-1,10])

fig.savefig('Output/Figures/Stats/Max_Variance_Velocity_1.png')
plt.close(fig)

# --------------------------------------
# Statistics of Min CG Iterations
# --------------------------------------

# Lists to store the data
data_mean = [[], [], [], []]
data_std_dev = [[], [], [], []]
data_var = [[], [], [], []]

# Find the relvant maximums across all the modes and find statistics of these
for j in range(0, len(Pressure[len(Timing_Files) - 1])):

    # List to hold the relvant data
    Data_P = []
    Data_V_1 = []
    Data_V_2 = []
    Data_V_3 = []

    # Loop finding the maximums for the given mode
    for i in range(0, len(Timing_Files)):

        # Not all have the same number of modes available, hence try used here
        try:
            Data_P.append(Min_Pressure_CG[i][j])
        except:
            continue

        try:
            Data_V_1.append(Min_Velocity_1_CG[i][j])
        except:
            continue

        try:
            Data_V_2.append(Min_Velocity_2_CG[i][j])
        except:
            continue

        try:
            Data_V_3.append(Min_Velocity_3_CG[i][j])
        except:
            continue

    # Find the mean, standard deviation and variance
    data_mean[0].append(np.mean(Data_P))
    data_std_dev[0].append(np.std(Data_P))
    data_var[0].append(np.var(Data_P))

    data_mean[1].append(np.mean(Data_V_1))
    data_std_dev[1].append(np.std(Data_V_1))
    data_var[1].append(np.var(Data_V_1))
    
    data_mean[2].append(np.mean(Data_V_2))
    data_std_dev[2].append(np.std(Data_V_2))
    data_var[2].append(np.var(Data_V_2))
    
    data_mean[3].append(np.mean(Data_V_3))
    data_std_dev[3].append(np.std(Data_V_3))
    data_var[3].append(np.var(Data_V_3))

# Produce the Plot
fig, ax = plt.subplots()
ax.plot(modes, data_mean[0], label = 'Pressure')
ax.plot(modes, data_mean[1], label = 'Velocity 1')
ax.plot(modes, data_mean[2], label = 'Velocity 2')
ax.plot(modes, data_mean[3], label = 'Velocity 3')
ax.set_xlabel('Plane Number')
ax.set_ylabel('Mean')
ax.set_title('Mean of Minimum Iterations vs Plane Number')
plt.legend(loc=1)

if (Scheme == 'IterativeFull' and Mesh == 'Pipe'):
    ax.set_ylim([0,1000])

if (Scheme == 'IterativeFull' and Mesh == 'Cylinder'):
    ax.set_ylim([0,1000])

if (Scheme == 'IterativeStaticCond' and Mesh == 'Pipe'):
    ax.set_ylim([0,300])

if (Scheme == 'IterativeStaticCond' and Mesh == 'Cylinder'):
    ax.set_ylim([0,300])

fig.savefig('Output/Figures/Stats/Min_Mean.png')
plt.close(fig)

# Produce the Plot
fig, ax = plt.subplots()
ax.plot(modes, data_std_dev[0], label = 'Pressure')
ax.plot(modes, data_std_dev[1], label = 'Velocity 1')
ax.plot(modes, data_std_dev[2], label = 'Velocity 2')
ax.plot(modes, data_std_dev[3], label = 'Velocity 3')
ax.set_xlabel('Plane Number')
ax.set_ylabel('Standard Deviation')
ax.set_title('Standard Deviation of Minimum Iterations vs Plane Number')
plt.legend(loc=1)

if (Scheme == 'IterativeFull' and Mesh == 'Pipe'):
    ax.set_ylim([-1,100])

if (Scheme == 'IterativeFull' and Mesh == 'Cylinder'):
    ax.set_ylim([-1,50])

if (Scheme == 'IterativeStaticCond' and Mesh == 'Pipe'):
    ax.set_ylim([-1,50])

if (Scheme == 'IterativeStaticCond' and Mesh == 'Cylinder'):
    ax.set_ylim([-1,10])

fig.savefig('Output/Figures/Stats/Min_Std_Dev.png')
plt.close(fig)

# Produce the Plot
fig, ax = plt.subplots()
ax.plot(modes, data_var[0], label = 'Pressure')
ax.plot(modes, data_var[1], label = 'Velocity 1')
ax.plot(modes, data_var[2], label = 'Velocity 2')
ax.plot(modes, data_var[3], label = 'Velocity 3')
ax.set_xlabel('Plane Number')
ax.set_ylabel('Variance')
ax.set_title('Variance of Minimum Iterations vs Plane Number')
plt.legend(loc=1)

if (Scheme == 'IterativeFull' and Mesh == 'Pipe'):
    ax.set_ylim([-1,100])

if (Scheme == 'IterativeFull' and Mesh == 'Cylinder'):
    ax.set_ylim([-1,50])

if (Scheme == 'IterativeStaticCond' and Mesh == 'Pipe'):
    ax.set_ylim([-1,50])

if (Scheme == 'IterativeStaticCond' and Mesh == 'Cylinder'):
    ax.set_ylim([-1,10])

fig.savefig('Output/Figures/Stats/Min_Variance_Velocity_1.png')
plt.close(fig)

# --------------------------------------
# Moving Window Standard Deviation
# --------------------------------------

# Shift the modes back for this part
modes = [x - 1 for x in modes]

# Loop over all the modes
for i in range(0, len(modes)):

    # Lists to hold the results for plotting
    Settling_Deviation_P = []
    Settling_Deviation_V_1 = []
    Settling_Deviation_V_2 = []
    Settling_Deviation_V_3 = []

    Settling_Time = []

    # Default Error to True
    Error = True
    
    # Pick out the data for the plane currently being looped over
    try:
        Data_P = Pressure[-1][str(modes[i])]
        Data_V_1 = Velocity_1[-1][str(modes[i])]
        Data_V_2 = Velocity_2[-1][str(modes[i])]
        Data_V_3 = Velocity_3[-1][str(modes[i])]

    except:
        Error = False

    # Loop over the data is no error thrown
    if Error is True:
        for j in range(0, len(Data_P) - 50):
 
            # Append the current timestep
            Settling_Time.append(j)
        
            # List to hold the data of the concerned timesteps
            Data_2_P = []
            Data_2_V_1 = []
            Data_2_V_2 = []
            Data_2_V_3 = []


            # Pick out the data from current timestep to the end
            for k in range(j, j + 50):
                Data_2_P.append(Data_P[k])
                Data_2_V_1.append(Data_V_1[k])
                Data_2_V_2.append(Data_V_2[k])
                Data_2_V_3.append(Data_V_3[k])
        
            # Take the standard deviation of this
            Settling_Deviation_P.append(np.std(Data_2_P))
            Settling_Deviation_V_1.append(np.std(Data_2_V_1))
            Settling_Deviation_V_2.append(np.std(Data_2_V_2))
            Settling_Deviation_V_3.append(np.std(Data_2_V_3))

        # Shift the settling time to account for the skipped steps
        Settling_Time = [x + Skip_Steps + 1 for x in Settling_Time]

        # Generate Save File and Title
        savefile = 'Output/Figures/Settling_Time/Set_Std_Dev' + '_' + str(modes[i] + 1) + '.png'
        title = 'Standard Deviation vs Timestep Cutoff: ' + 'Plane = ' + str(modes[i] + 1)

        # Produce the Plot
        fig, ax = plt.subplots()
        ax.plot(Settling_Time, Settling_Deviation_P, label = 'Pressure')
        ax.plot(Settling_Time, Settling_Deviation_V_1, label = 'Velocity 1')
        ax.plot(Settling_Time, Settling_Deviation_V_2, label = 'Velocity 2')
        ax.plot(Settling_Time, Settling_Deviation_V_3, label = 'Velocity 3')
        plt.legend(loc=1)

        ax.set_xlabel('Time Step')
        ax.set_ylabel('Standard Deviation')
        ax.set_title(title)

        if (Scheme == 'IterativeFull' and Mesh == 'Pipe'):
            ax.set_ylim([-1,10])

        if (Scheme == 'IterativeFull' and Mesh == 'Cylinder'):
            ax.set_ylim([-1,50])

        if (Scheme == 'IterativeStaticCond' and Mesh == 'Pipe'):
            ax.set_ylim([-1,10])

        if (Scheme == 'IterativeStaticCond' and Mesh == 'Cylinder'):
            ax.set_ylim([-1,10])

        fig.savefig(savefile)
        plt.close(fig)

#--------------------------------------
# End of Program
#--------------------------------------
